import ts from "typescript";
import pkg from "../package.json" assert { type: "json" };
import type { TypeRegistry } from "./registry.js";
import type { ExternalImport, TypeDeclaration } from "./types.js";

const version = (pkg as { version?: string }).version ?? "development";

export class OutputGenerator {
  private registry: TypeRegistry;
  private usedDeclarations: Set<symbol>;
  private usedExternals: Map<string, Set<ExternalImport>>;
  private nameMap: Map<string, string>;
  private options: {
    noBanner?: boolean;
    sortNodes?: boolean;
    umdModuleName?: string;
    includeEmptyExport?: boolean;
    allowedTypesLibraries?: string[];
    importedLibraries?: string[];
    referencedTypes?: Set<string>;
    entryExportEquals?: ts.ExportAssignment | null;
    entryExportDefault?: ts.ExportAssignment | null;
    entryExportDefaultName?: string | null;
  };

  constructor(
    registry: TypeRegistry,
    usedDeclarations: Set<symbol>,
    usedExternals: Map<string, Set<ExternalImport>>,
    options: {
      noBanner?: boolean;
      sortNodes?: boolean;
      umdModuleName?: string;
      includeEmptyExport?: boolean;
      allowedTypesLibraries?: string[];
      importedLibraries?: string[];
      referencedTypes?: Set<string>;
      entryExportEquals?: ts.ExportAssignment | null;
      entryExportDefault?: ts.ExportAssignment | null;
      entryExportDefaultName?: string | null;
    } = {},
  ) {
    this.registry = registry;
    this.usedDeclarations = usedDeclarations;
    this.usedExternals = usedExternals;
    this.nameMap = new Map();
    this.options = options;
  }

  generate(): string {
    const lines: string[] = [];

    const banner = !this.options.noBanner ? `// Generated by @qlik/dts-bundler@${version}` : null;
    const referenceDirectives = this.generateReferenceDirectives();
    const externalImports = this.usedExternals.size > 0 ? this.generateExternalImports() : [];

    this.buildNameMap();
    const declarations = this.generateDeclarations();
    const namespaces = this.generateNamespaces();
    const exportEquals = this.generateExportEquals();
    const exportDefault = this.generateExportDefault();

    const umdDeclaration = this.options.umdModuleName ? [`export as namespace ${this.options.umdModuleName};`] : [];
    const emptyExport = this.options.includeEmptyExport ? ["export {};"] : [];

    const appendSection = (section: string[]): void => {
      if (section.length === 0) return;
      if (lines.length > 0) lines.push("");
      lines.push(...section);
    };

    if (banner) {
      lines.push(banner);
    }

    appendSection(referenceDirectives);
    appendSection(externalImports);
    appendSection(namespaces);
    appendSection(declarations);

    // export = should appear immediately after declarations without blank line
    if (exportEquals.length > 0) {
      lines.push(...exportEquals);
    }

    // export default should appear after declarations
    if (exportDefault.length > 0) {
      if (lines.length > 0) lines.push("");
      lines.push(...exportDefault);
    }

    appendSection(umdDeclaration);
    appendSection(emptyExport);

    return `${lines.join("\n")}\n`;
  }

  private buildNameMap(): void {
    for (const id of this.usedDeclarations) {
      const declaration = this.registry.getDeclaration(id);
      if (declaration && declaration.name !== declaration.normalizedName) {
        const key = `${declaration.sourceFile}:${declaration.name}`;
        this.nameMap.set(key, declaration.normalizedName);
      }
    }
  }

  private generateExternalImports(): string[] {
    const lines: string[] = [];
    const sortedModules = Array.from(this.usedExternals.keys()).sort();

    for (const moduleName of sortedModules) {
      const imports = Array.from(this.usedExternals.get(moduleName) ?? []);
      if (imports.length === 0) continue;

      // Separate CommonJS import = require() from ES6 imports
      const cjsImports = imports.filter((imp) => imp.normalizedName.startsWith("= "));
      const esImports = imports.filter((imp) => !imp.normalizedName.startsWith("= "));

      // Emit CommonJS import = require() statements
      for (const cjsImport of cjsImports) {
        const importName = cjsImport.normalizedName.substring(2); // Remove "= " prefix
        lines.push(`import ${importName} = require("${moduleName}");`);
      }

      // Emit ES6 imports if any
      if (esImports.length === 0) continue;

      const isTypeOnly = esImports.every((imp) => imp.isTypeOnly);
      const typePrefix = isTypeOnly ? "type " : "";

      const hasNamespace = esImports.some((imp) => imp.normalizedName.startsWith("* as "));
      const defaultImports = esImports.filter((imp) => imp.normalizedName.startsWith("default as "));
      const namedImports = esImports.filter(
        (imp) => !imp.normalizedName.startsWith("* as ") && !imp.normalizedName.startsWith("default as "),
      );

      if (hasNamespace) {
        const importList = esImports.map((imp) => imp.normalizedName).sort();
        lines.push(`import ${typePrefix}${importList.join(", ")} from "${moduleName}";`);
      } else if (defaultImports.length > 0 && namedImports.length > 0) {
        // Both default and named imports
        const defaultName = defaultImports[0].normalizedName.substring("default as ".length);
        const namedList = namedImports.map((imp) => imp.normalizedName).sort();
        lines.push(`import ${typePrefix}${defaultName}, { ${namedList.join(", ")} } from "${moduleName}";`);
      } else if (defaultImports.length > 0) {
        // Only default imports
        for (const defaultImport of defaultImports) {
          const defaultName = defaultImport.normalizedName.substring("default as ".length);
          lines.push(`import ${typePrefix}${defaultName} from "${moduleName}";`);
        }
      } else if (namedImports.length > 0) {
        // Only named imports
        const importList = namedImports.map((imp) => imp.normalizedName).sort();
        lines.push(`import ${typePrefix}{ ${importList.join(", ")} } from "${moduleName}";`);
      }
    }

    return lines;
  }

  private generateDeclarations(): string[] {
    const lines: string[] = [];

    const sorted = this.topologicalSort();
    const ordered = this.options.sortNodes
      ? [...sorted].sort((a, b) => {
          const rank = OutputGenerator.getSortRank(a) - OutputGenerator.getSortRank(b);
          if (rank !== 0) return rank;
          return a.normalizedName.localeCompare(b.normalizedName);
        })
      : sorted;

    for (const declaration of ordered) {
      let text = declaration.getText();

      // Keep export keyword if the declaration was originally exported or is marked as exported
      // But suppress export if this declaration is exported via export = or export default statement
      const hasDefaultModifier =
        ts.canHaveModifiers(declaration.node) &&
        (ts.getModifiers(declaration.node)?.some((mod) => mod.kind === ts.SyntaxKind.DefaultKeyword) ?? false);
      const suppressExportForDefault = declaration.isExportedAsDefault && hasDefaultModifier;

      const shouldHaveExport =
        !declaration.isExportEquals &&
        !suppressExportForDefault &&
        (declaration.isExported || declaration.wasOriginallyExported);

      if (!shouldHaveExport) {
        text = OutputGenerator.stripExportModifier(text);
      }

      //Add declare keyword to class/enum/function declarations
      // Interfaces and types don't need declare keyword in .d.ts files
      // For exported declarations, only add declare if not already present
      if (!text.trim().startsWith("declare ")) {
        text = OutputGenerator.addDeclareKeyword(text);
      }

      // For namespace/module declarations, normalize "module" keyword to "namespace"
      if (ts.isModuleDeclaration(declaration.node)) {
        text = text.replace(/\b((?:export\s+)?declare\s+)module\b/, "$1namespace");
      }

      // Strip implementation details for declaration files
      text = OutputGenerator.stripImplementationDetails(text);

      // For namespace/module declarations, remove export modifiers from members
      if (ts.isModuleDeclaration(declaration.node)) {
        text = OutputGenerator.stripNamespaceMemberExports(text);
      }

      // Handle variable declarations - add type annotations for namespace references
      if (ts.isVariableStatement(declaration.node)) {
        text = this.transformVariableDeclaration(text, declaration);
      }

      text = this.replaceRenamedReferences(text, declaration);

      lines.push(text);
    }

    return lines;
  }

  private generateNamespaces(): string[] {
    const lines: string[] = [];
    const usedNamespaces = new Map<string, { sourceFile: string; declarations: symbol[] }>();

    // Find all namespace imports that are referenced in used declarations
    for (const declId of this.usedDeclarations) {
      const decl = this.registry.getDeclaration(declId);
      if (!decl) continue;

      // Check if this declaration has namespace dependencies
      for (const namespaceName of decl.namespaceDependencies) {
        // Find the namespace info from the registry
        const key = `${decl.sourceFile}:${namespaceName}`;
        const nsInfo = this.registry.namespaceImports.get(key);

        if (nsInfo && !usedNamespaces.has(namespaceName)) {
          // Collect all declarations from the source file
          const fileDeclarations = this.registry.declarationsByFile.get(nsInfo.sourceFile);
          if (fileDeclarations) {
            const usedFromFile = Array.from(fileDeclarations).filter((id) => this.usedDeclarations.has(id));
            if (usedFromFile.length > 0) {
              usedNamespaces.set(namespaceName, {
                sourceFile: nsInfo.sourceFile,
                declarations: usedFromFile,
              });
            }
          }
        }
      }
    }

    // Generate namespace blocks
    for (const [namespaceName, info] of usedNamespaces.entries()) {
      lines.push(`declare namespace ${namespaceName} {`);

      for (const declId of info.declarations) {
        const declaration = this.registry.getDeclaration(declId);
        if (!declaration) continue;

        // Export the declaration within the namespace using its original name
        lines.push(`  export { ${declaration.name} };`);
      }

      lines.push(`}`);
    }

    return lines;
  }

  private generateExportEquals(): string[] {
    if (!this.options.entryExportEquals) {
      return [];
    }

    const statement = this.options.entryExportEquals;
    if (!ts.isIdentifier(statement.expression)) {
      return [];
    }

    const exportedName = statement.expression.text;
    const normalizedName = this.nameMap.get(exportedName) || exportedName;

    return [`export = ${normalizedName};`];
  }

  private generateExportDefault(): string[] {
    if (this.options.entryExportDefaultName) {
      const normalizedName =
        this.nameMap.get(this.options.entryExportDefaultName) || this.options.entryExportDefaultName;
      return [`export { ${normalizedName} as default };`];
    }

    if (!this.options.entryExportDefault) {
      return [];
    }

    const statement = this.options.entryExportDefault;
    const expression = statement.expression;

    let exportedName: string;

    if (ts.isIdentifier(expression)) {
      // export default SomeIdentifier
      exportedName = expression.text;
    } else if (
      (ts.isClassDeclaration(expression) ||
        ts.isFunctionDeclaration(expression) ||
        ts.isInterfaceDeclaration(expression) ||
        ts.isEnumDeclaration(expression)) &&
      expression.name
    ) {
      // export default class/function/etc with a name
      exportedName = expression.name.text;
    } else {
      // export default <expression without name>
      return [];
    }

    const normalizedName = this.nameMap.get(exportedName) || exportedName;

    return [`export { ${normalizedName} as default };`];
  }

  /* eslint-disable no-param-reassign */
  private static stripExportModifier(text: string): string {
    // Strip both "export default" and "export", handling leading whitespace
    text = text.replace(/export\s+default\s+/, "");
    text = text.replace(/export\s+/, "");
    return text;
  }
  /* eslint-enable no-param-reassign */

  private static addDeclareKeyword(text: string): string {
    // Only add declare to class, enum, function, namespace, and module (not interface or type)
    // Handle both "export class" and "class" patterns
    const match = text.match(
      /^((?:\s*(?:\/\*[\s\S]*?\*\/\s*|\/\/[^\n]*\n\s*)*)(?:export\s+)?)(class|enum|function|namespace|module)(?:\s|$)/,
    );
    if (match) {
      const prefix = match[1]; // comments and export keyword
      const declarationKeyword = match[2]; // class, enum, or function
      const rest = text.substring(match[0].length - 1); // everything after the keyword
      return `${prefix}declare ${declarationKeyword}${rest}`;
    }
    return text;
  }

  private static stripNamespaceMemberExports(text: string): string {
    const openBraceIndex = text.indexOf("{");
    const closeBraceIndex = text.lastIndexOf("}");
    if (openBraceIndex === -1 || closeBraceIndex === -1 || closeBraceIndex <= openBraceIndex) {
      return text;
    }

    const prefix = text.slice(0, openBraceIndex + 1);
    const body = text.slice(openBraceIndex + 1, closeBraceIndex);
    const suffix = text.slice(closeBraceIndex);

    const cleanedBody = body.replace(
      /(^|\n)(\s*)export\s+(?=(?:declare\s+)?(?:namespace|module|interface|type|class|enum|const|let|var|function)\b)/g,
      "$1$2",
    );

    return `${prefix}${cleanedBody}${suffix}`;
  }

  /* eslint-disable no-param-reassign */
  private static stripImplementationDetails(text: string): string {
    // Strip public/private/protected modifiers from class members
    text = text.replace(/^(\s*)(public|private|protected)\s+/gm, "$1");

    // Strip property initializers (e.g., field: string = ""; becomes field: string;)
    // This should match property declarations (not methods) with initializers
    // Property pattern: identifier : type = value;
    // Avoid matching methods which have () in their signature
    text = text.replace(/^(\s*)([a-zA-Z_$][\w$]*)\s*:\s*([^;=()]+?)\s*=\s*[^;]+;/gm, "$1$2: $3;");

    // Strip function bodies - replace { ... } with just semicolon
    text = text.replace(/^((?:export\s+)?(?:declare\s+)?function\s+[^{]+?)\s*\{[^}]*\}/gm, "$1;");

    return text;
  }
  /* eslint-enable no-param-reassign */

  /* eslint-disable no-param-reassign, @typescript-eslint/class-methods-use-this */
  private transformVariableDeclaration(text: string, declaration: TypeDeclaration): string {
    // Check if this variable has namespace dependencies
    if (declaration.namespaceDependencies.size > 0) {
      // Transform: export const Lib = lib; -> export declare const Lib: typeof lib;
      const namespaceNames = Array.from(declaration.namespaceDependencies);
      for (const nsName of namespaceNames) {
        // Match pattern: const VarName = nsName;
        const pattern = new RegExp(`(const\\s+${declaration.name})\\s*=\\s*${nsName}\\s*;`, "g");
        text = text.replace(pattern, `$1: typeof ${nsName};`);
      }
    }

    // Add declare keyword to variable declarations if they're not exported
    if (!declaration.isExported && !text.trim().startsWith("declare ")) {
      text = text.replace(/^((?:\s*(?:\/\*[\s\S]*?\*\/\s*|\/\/[^\n]*\n\s*)*))(const|let|var)\s+/, "$1declare $2 ");
    } else if (declaration.isExported) {
      // For exported variables, add declare after export
      text = text.replace(
        /^((?:\s*(?:\/\*[\s\S]*?\*\/\s*|\/\/[^\n]*\n\s*)*)export\s+)(const|let|var)\s+/,
        "$1declare $2 ",
      );
    }

    return text;
  }
  /* eslint-enable no-param-reassign, @typescript-eslint/class-methods-use-this */

  private topologicalSort(): TypeDeclaration[] {
    const sorted: TypeDeclaration[] = [];
    const visited = new Set<symbol>();
    const visiting = new Set<symbol>();

    const visit = (id: symbol): void => {
      if (visited.has(id)) return;
      if (visiting.has(id)) {
        return;
      }

      visiting.add(id);
      const declaration = this.registry.getDeclaration(id);

      if (declaration) {
        for (const depId of declaration.dependencies) {
          if (this.usedDeclarations.has(depId)) {
            visit(depId);
          }
        }

        visiting.delete(id);
        visited.add(id);
        sorted.push(declaration);
      }
    };

    const used = Array.from(this.usedDeclarations);
    const exported = used.filter((id) => {
      const decl = this.registry.getDeclaration(id);
      return decl && decl.isExported;
    });
    const nonExported = used.filter((id) => {
      const decl = this.registry.getDeclaration(id);
      return decl && !decl.isExported;
    });

    for (const id of nonExported) {
      visit(id);
    }
    for (const id of exported) {
      visit(id);
    }

    return sorted;
  }

  private replaceRenamedReferences(text: string, declaration: TypeDeclaration): string {
    let result = text;

    if (declaration.name !== declaration.normalizedName) {
      const regex = new RegExp(`\\b(type|interface|class|enum)\\s+${declaration.name}\\b`, "g");
      result = result.replace(regex, `$1 ${declaration.normalizedName}`);
    }

    for (const depId of declaration.dependencies) {
      const depDecl = this.registry.getDeclaration(depId);
      if (depDecl && depDecl.name !== depDecl.normalizedName) {
        const regex = new RegExp(`\\b${depDecl.name}\\b(?![_])`, "g");
        result = result.replace(regex, depDecl.normalizedName);
      }
    }

    for (const [moduleName, importNames] of declaration.externalDependencies.entries()) {
      const moduleImports = this.registry.externalImports.get(moduleName);
      if (!moduleImports) continue;

      for (const importName of importNames) {
        const externalImport = moduleImports.get(importName);
        if (!externalImport) continue;

        const originalName = OutputGenerator.extractImportName(externalImport.originalName);
        const normalizedName = OutputGenerator.extractImportName(externalImport.normalizedName);

        if (originalName !== normalizedName) {
          const regex = new RegExp(`\\b${originalName}\\b(?![_])`, "g");
          result = result.replace(regex, normalizedName);
        }
      }
    }

    return result;
  }

  private static extractImportName(importStr: string): string {
    if (importStr.startsWith("default as ")) {
      return importStr.replace("default as ", "");
    }
    if (importStr.startsWith("* as ")) {
      return importStr.replace("* as ", "");
    }
    if (importStr.includes(" as ")) {
      const parts = importStr.split(" as ");
      return parts[1].trim();
    }
    return importStr;
  }

  private static getSortRank(declaration: TypeDeclaration): number {
    const node = declaration.node;
    if (ts.isInterfaceDeclaration(node)) return 1;
    if (ts.isTypeAliasDeclaration(node)) return 2;
    if (ts.isClassDeclaration(node)) return 3;
    if (ts.isEnumDeclaration(node)) return 4;
    if (ts.isModuleDeclaration(node)) return 5;
    return 10;
  }

  private generateReferenceDirectives(): string[] {
    const directives: string[] = [];
    const { referencedTypes, allowedTypesLibraries } = this.options;

    if (!referencedTypes || referencedTypes.size === 0 || !allowedTypesLibraries) {
      return directives;
    }

    // Generate triple-slash directives for types that are both:
    // 1. Referenced with preserve="true" in source files
    // 2. Listed in allowedTypesLibraries
    const sortedTypes = Array.from(referencedTypes).sort();
    for (const typeName of sortedTypes) {
      if (allowedTypesLibraries.includes(typeName)) {
        directives.push(`/// <reference types="${typeName}" />`);
      }
    }

    return directives;
  }
}
