import fs from "node:fs";
import path from "node:path";
import ts from "typescript";
import pkg from "../package.json" assert { type: "json" };
import { AstPrinter } from "./ast-printer.js";
import { getModifiers, modifiersToMap, recreateRootLevelNodeWithModifiers } from "./helpers/ast-transformer.js";
import { buildEntryExportData, type EntryExportData } from "./helpers/entry-exports.js";
import { normalizePrintedStatement } from "./helpers/print-normalizer.js";
import type { TypeRegistry } from "./registry.js";
import { ExportKind, type ExternalImport, type TypeDeclaration } from "./types.js";
import { VariableDeclarationEmitter } from "./variable-declaration-emitter.js";

const version = (pkg as { version?: string }).version ?? "development";

export class OutputGenerator {
  private registry: TypeRegistry;
  private usedDeclarations: Set<symbol>;
  private usedExternals: Map<string, Set<ExternalImport>>;
  private nameMap: Map<string, string>;
  private extraDefaultExports: Set<string>;
  private variableDeclarationEmitter: VariableDeclarationEmitter | null;
  private astPrinter: AstPrinter;
  private namespaceValueAliasesByFile: Map<string, Set<string>>;
  private entryExportData: EntryExportData | null = null;
  private options: {
    noBanner?: boolean;
    sortNodes?: boolean;
    umdModuleName?: string;
    includeEmptyExport?: boolean;
    allowedTypesLibraries?: string[];
    importedLibraries?: string[];
    referencedTypes?: Set<string>;
    detectedTypesLibraries?: Set<string>;
    entryExportEquals?: ts.ExportAssignment | null;
    entryExportDefault?: ts.ExportAssignment | null;
    entryExportDefaultName?: string | null;
    typeChecker?: ts.TypeChecker;
    preserveConstEnums?: boolean;
    respectPreserveConstEnum?: boolean;
    entryFile?: string;
    entryImportedFiles?: Set<string>;
    importTypeResolver?: {
      shouldInline: (importPath: string) => boolean;
      resolveImport: (fromFile: string, importPath: string) => string | null;
    };
  };

  constructor(
    registry: TypeRegistry,
    usedDeclarations: Set<symbol>,
    usedExternals: Map<string, Set<ExternalImport>>,
    options: {
      noBanner?: boolean;
      sortNodes?: boolean;
      umdModuleName?: string;
      includeEmptyExport?: boolean;
      allowedTypesLibraries?: string[];
      importedLibraries?: string[];
      referencedTypes?: Set<string>;
      detectedTypesLibraries?: Set<string>;
      entryExportEquals?: ts.ExportAssignment | null;
      entryExportDefault?: ts.ExportAssignment | null;
      entryExportDefaultName?: string | null;
      typeChecker?: ts.TypeChecker;
      preserveConstEnums?: boolean;
      respectPreserveConstEnum?: boolean;
      entryFile?: string;
      entryImportedFiles?: Set<string>;
      importTypeResolver?: {
        shouldInline: (importPath: string) => boolean;
        resolveImport: (fromFile: string, importPath: string) => string | null;
      };
    } = {},
  ) {
    this.registry = registry;
    this.usedDeclarations = usedDeclarations;
    this.usedExternals = usedExternals;
    this.nameMap = new Map();
    this.extraDefaultExports = new Set();
    this.astPrinter = new AstPrinter();
    this.namespaceValueAliasesByFile = this.collectNamespaceValueAliases();
    this.variableDeclarationEmitter = options.typeChecker
      ? new VariableDeclarationEmitter(
          options.typeChecker,
          (name) => this.extraDefaultExports.add(name),
          this.astPrinter,
          (declarations) => this.buildRenameMapForDeclarations(declarations),
        )
      : null;
    this.options = options;
  }

  generate(): string {
    const lines: string[] = [];

    const banner = !this.options.noBanner ? `// Generated by @qlik/dts-bundler@${version}` : null;
    const referenceDirectives = this.generateReferenceDirectives();
    const externalPrelude = this.generateExternalPrelude();

    this.buildNameMap();
    const declarations = this.generateDeclarations();
    const namespaces = this.generateNamespaces();
    const exportEquals = this.generateExportEquals();
    const starExports = this.generateStarExports();
    const namespaceExports = this.generateNamespaceExports();
    const namedExports = this.generateNamedExports();
    const exportDefault = this.generateExportDefault();

    const umdDeclaration = this.options.umdModuleName ? [`export as namespace ${this.options.umdModuleName};`] : [];
    const emptyExport = this.options.includeEmptyExport ? ["export {};"] : [];

    const appendSection = (section: string[]): void => {
      if (section.length === 0) return;
      if (lines.length > 0) lines.push("");
      lines.push(...section);
    };

    if (banner) {
      lines.push(banner);
    }

    appendSection(referenceDirectives);
    appendSection(externalPrelude.lines);
    appendSection(namespaces);
    appendSection(declarations);

    // export = should appear immediately after declarations without blank line
    if (exportEquals.length > 0) {
      lines.push(...exportEquals);
    }

    appendSection(starExports);

    appendSection(namespaceExports.blocks);
    if (namespaceExports.exportList.length > 0) {
      if (lines.length > 0) lines.push("");
      lines.push(...namespaceExports.exportList);
    }

    if (namedExports.length > 0) {
      if (lines.length > 0) lines.push("");
      lines.push(...namedExports);
    }

    // export default should appear after declarations
    if (exportDefault.length > 0) {
      if (lines.length > 0) lines.push("");
      lines.push(...exportDefault);
    }

    appendSection(umdDeclaration);
    appendSection(emptyExport);

    return `${lines.join("\n")}\n`;
  }

  private buildNameMap(): void {
    for (const id of this.usedDeclarations) {
      const declaration = this.registry.getDeclaration(id);
      if (declaration && declaration.name !== declaration.normalizedName) {
        const key = `${declaration.sourceFile}:${declaration.name}`;
        this.nameMap.set(key, declaration.normalizedName);
      }
    }
  }

  private generateExternalImports(): string[] {
    const lines: string[] = [];
    const sortedModules = Array.from(this.usedExternals.keys()).sort();

    for (const moduleName of sortedModules) {
      const imports = Array.from(this.usedExternals.get(moduleName) ?? []);
      if (imports.length === 0) continue;

      // Separate CommonJS import = require() from ES6 imports
      const cjsImports = imports.filter((imp) => imp.normalizedName.startsWith("= "));
      const esImports = imports.filter((imp) => !imp.normalizedName.startsWith("= "));

      // Emit CommonJS import = require() statements
      for (const cjsImport of cjsImports) {
        const importName = cjsImport.normalizedName.substring(2); // Remove "= " prefix
        lines.push(`import ${importName} = require("${moduleName}");`);
      }

      // Emit ES6 imports if any
      if (esImports.length === 0) continue;

      const isTypeOnly = esImports.every((imp) => imp.isTypeOnly);
      const typePrefix = isTypeOnly ? "type " : "";

      const namespaceImports = esImports.filter((imp) => imp.normalizedName.startsWith("* as "));
      const nonNamespaceImports = esImports.filter((imp) => !imp.normalizedName.startsWith("* as "));

      const emittedNamespaces = new Set<string>();
      for (const namespaceImport of namespaceImports) {
        if (emittedNamespaces.has(namespaceImport.normalizedName)) {
          continue;
        }
        emittedNamespaces.add(namespaceImport.normalizedName);
        const namespacePrefix = namespaceImport.isTypeOnly ? "type " : "";
        lines.push(`import ${namespacePrefix}${namespaceImport.normalizedName} from "${moduleName}";`);
      }

      if (nonNamespaceImports.length === 0) {
        continue;
      }

      const defaultImports = nonNamespaceImports.filter((imp) => imp.normalizedName.startsWith("default as "));
      const namedImports = nonNamespaceImports.filter((imp) => !imp.normalizedName.startsWith("default as "));
      const primaryDefault = defaultImports.find((imp) => imp.isDefaultImport) ?? null;
      const hasDefaultImport = Boolean(primaryDefault);
      const namedListOrdered = nonNamespaceImports
        .filter((imp) => imp !== primaryDefault)
        .map((imp) => imp.normalizedName);
      const preferSingleLineNamed = namespaceImports.length > 0 && !hasDefaultImport && defaultImports.length === 0;

      if (hasDefaultImport) {
        const defaultName = primaryDefault?.normalizedName.substring("default as ".length) ?? "";
        if (namedListOrdered.length > 0) {
          if (namedListOrdered.length > 1) {
            const namedBlock = namedListOrdered.map((name) => `  ${name},`).join("\n");
            lines.push(`import ${typePrefix}${defaultName}, {\n${namedBlock}\n} from "${moduleName}";`);
          } else {
            lines.push(`import ${typePrefix}${defaultName}, { ${namedListOrdered[0]} } from "${moduleName}";`);
          }
        } else {
          lines.push(`import ${typePrefix}${defaultName} from "${moduleName}";`);
        }
      } else if (defaultImports.length > 0 || namedImports.length > 0) {
        if (namedListOrdered.length > 1) {
          if (preferSingleLineNamed) {
            lines.push(`import ${typePrefix}{ ${namedListOrdered.join(", ")} } from "${moduleName}";`);
          } else {
            const namedBlock = namedListOrdered.map((name) => `  ${name},`).join("\n");
            lines.push(`import ${typePrefix}{\n${namedBlock}\n} from "${moduleName}";`);
          }
        } else if (namedListOrdered.length === 1) {
          lines.push(`import ${typePrefix}{ ${namedListOrdered[0]} } from "${moduleName}";`);
        }
      }
    }

    return lines;
  }

  private generateExternalPrelude(): { lines: string[] } {
    const { exportFromByModule, excludedExternalImports, requiredExternalImports } = this.getEntryExportData();

    const filteredExternals = this.filterExternalImports(excludedExternalImports, requiredExternalImports);
    const lines: string[] = [];

    for (const [moduleName, exportItems] of exportFromByModule.entries()) {
      if (exportItems.length > 0) {
        lines.push(OutputGenerator.buildExportFromLine(moduleName, exportItems));
      }
    }

    const sortedModules = Array.from(filteredExternals.keys()).sort();
    for (const moduleName of sortedModules) {
      const imports = filteredExternals.get(moduleName);
      if (imports && imports.size > 0) {
        lines.push(...OutputGenerator.buildExternalImportLines(moduleName, imports));
      }
    }

    return { lines };
  }

  private generateNamedExports(): string[] {
    const { exportListItems } = this.getEntryExportData();
    if (exportListItems.length === 0) {
      return [];
    }

    if (exportListItems.length <= 3) {
      return [`export { ${exportListItems.join(", ")} };`];
    }

    const lines = ["export {"];
    for (const item of exportListItems) {
      lines.push(`  ${item},`);
    }
    lines.push("};");
    return lines;
  }

  private getEntryExportData(): EntryExportData {
    if (this.entryExportData) {
      return this.entryExportData;
    }
    this.entryExportData = buildEntryExportData({
      registry: this.registry,
      usedDeclarations: this.usedDeclarations,
      entryFile: this.options.entryFile,
      nameMap: this.nameMap,
      getNormalizedExternalImportName: this.getNormalizedExternalImportName.bind(this),
      extractImportName: OutputGenerator.extractImportName,
      entryAliasMap: this.getEntryExportAliasMap(),
    });
    return this.entryExportData;
  }

  private getEntryExportAliasMap(): Map<string, { sourceFile: string; originalName: string }> {
    const aliasMap = new Map<string, { sourceFile: string; originalName: string }>();
    const entryFile = this.options.entryFile;
    if (!entryFile) {
      return aliasMap;
    }

    try {
      const entryDir = path.dirname(entryFile);
      const sourceText = fs.readFileSync(entryFile, "utf8");
      const sourceFile = ts.createSourceFile(entryFile, sourceText, ts.ScriptTarget.Latest, true);

      for (const statement of sourceFile.statements) {
        if (!ts.isExportDeclaration(statement)) continue;
        if (!statement.moduleSpecifier || !ts.isStringLiteral(statement.moduleSpecifier)) continue;
        if (!statement.exportClause || !ts.isNamedExports(statement.exportClause)) continue;

        const modulePath = statement.moduleSpecifier.text;
        const sourcePath = this.resolveSourceFileFromRegistry(entryDir, modulePath);
        if (!sourcePath) continue;

        for (const element of statement.exportClause.elements) {
          const exportedName = element.name.text;
          const originalName = element.propertyName?.text ?? exportedName;
          aliasMap.set(exportedName, { sourceFile: sourcePath, originalName });
        }
      }
    } catch {
      // ignore
    }

    return aliasMap;
  }
  private filterExternalImports(excluded: Set<string>, required: Set<string>): Map<string, Set<ExternalImport>> {
    const result = new Map<string, Set<ExternalImport>>();

    const addImport = (moduleName: string, externalImport: ExternalImport): void => {
      if (!result.has(moduleName)) {
        result.set(moduleName, new Set());
      }
      result.get(moduleName)?.add(externalImport);
    };

    for (const [moduleName, imports] of this.usedExternals.entries()) {
      for (const externalImport of imports) {
        const key = `${moduleName}:${externalImport.originalName}`;
        if (excluded.has(key)) {
          continue;
        }
        addImport(moduleName, externalImport);
      }
    }

    for (const key of required) {
      if (excluded.has(key)) {
        continue;
      }
      const [moduleName, importName] = key.split(":");
      const moduleImports = this.registry.externalImports.get(moduleName);
      const externalImport = moduleImports?.get(importName);
      if (externalImport) {
        addImport(moduleName, externalImport);
      }
    }

    return result;
  }

  private resolveSourceFileFromRegistry(entryDir: string, modulePath: string): string | null {
    const basePath = path.resolve(entryDir, modulePath);
    const candidates = [
      basePath,
      `${basePath}.ts`,
      `${basePath}.d.ts`,
      `${basePath}.mts`,
      `${basePath}.cts`,
      path.join(basePath, "index.ts"),
      path.join(basePath, "index.d.ts"),
      path.join(basePath, "index.mts"),
      path.join(basePath, "index.cts"),
    ];

    for (const candidate of candidates) {
      if (this.registry.declarationsByFile.has(candidate)) {
        return candidate;
      }
    }

    const normalizedBase = basePath.replace(/\\/g, "/");
    for (const filePath of this.registry.declarationsByFile.keys()) {
      const normalizedPath = filePath.replace(/\\/g, "/");
      if (normalizedPath === normalizedBase) {
        return filePath;
      }
      if (normalizedPath.endsWith(`${normalizedBase}.ts`)) {
        return filePath;
      }
      if (normalizedPath.endsWith(`${normalizedBase}.d.ts`)) {
        return filePath;
      }
      if (normalizedPath.endsWith(`${normalizedBase}.mts`)) {
        return filePath;
      }
      if (normalizedPath.endsWith(`${normalizedBase}.cts`)) {
        return filePath;
      }
    }

    return null;
  }

  private static buildExportFromLine(moduleName: string, items: string[]): string {
    const unique = Array.from(new Set(items));
    if (unique.length === 1) {
      return `export { ${unique[0]} } from "${moduleName}";`;
    }

    if (unique.length <= 2) {
      return `export { ${unique.join(", ")} } from "${moduleName}";`;
    }

    const lines = ["export {"];
    for (const item of unique) {
      lines.push(`  ${item},`);
    }
    lines.push(`} from "${moduleName}";`);
    return lines.join("\n");
  }

  private static buildExternalImportLines(moduleName: string, imports: Set<ExternalImport>): string[] {
    const lines: string[] = [];
    const importsArray = Array.from(imports);

    // Separate CommonJS import = require() from ES6 imports
    const cjsImports = importsArray.filter((imp) => imp.normalizedName.startsWith("= "));
    const esImports = importsArray.filter((imp) => !imp.normalizedName.startsWith("= "));

    // Emit CommonJS import = require() statements
    for (const cjsImport of cjsImports) {
      const importName = cjsImport.normalizedName.substring(2); // Remove "= " prefix
      lines.push(`import ${importName} = require("${moduleName}");`);
    }

    // Emit ES6 imports if any
    if (esImports.length === 0) return lines;

    const isTypeOnly = esImports.every((imp) => imp.isTypeOnly);
    const typePrefix = isTypeOnly ? "type " : "";

    const namespaceImports = esImports.filter((imp) => imp.normalizedName.startsWith("* as "));
    const nonNamespaceImports = esImports.filter((imp) => !imp.normalizedName.startsWith("* as "));

    const emittedNamespaces = new Set<string>();
    for (const namespaceImport of namespaceImports) {
      if (emittedNamespaces.has(namespaceImport.normalizedName)) {
        continue;
      }
      emittedNamespaces.add(namespaceImport.normalizedName);
      const namespacePrefix = namespaceImport.isTypeOnly ? "type " : "";
      lines.push(`import ${namespacePrefix}${namespaceImport.normalizedName} from "${moduleName}";`);
    }

    if (nonNamespaceImports.length === 0) {
      return lines;
    }

    const defaultImports = nonNamespaceImports.filter((imp) => imp.normalizedName.startsWith("default as "));
    const namedImports = nonNamespaceImports.filter((imp) => !imp.normalizedName.startsWith("default as "));
    const primaryDefault = defaultImports.find((imp) => imp.isDefaultImport) ?? null;
    const hasDefaultImport = Boolean(primaryDefault);
    const namedListOrdered = nonNamespaceImports
      .filter((imp) => imp !== primaryDefault)
      .map((imp) => imp.normalizedName)
      .sort((a, b) => OutputGenerator.extractImportName(a).localeCompare(OutputGenerator.extractImportName(b)));
    const preferSingleLineNamed = namespaceImports.length > 0 && !hasDefaultImport && defaultImports.length === 0;

    if (hasDefaultImport) {
      const defaultName = primaryDefault?.normalizedName.substring("default as ".length) ?? "";
      if (namedListOrdered.length > 0) {
        if (namedListOrdered.length > 1) {
          const namedBlock = namedListOrdered.map((name) => `  ${name},`).join("\n");
          lines.push(`import ${typePrefix}${defaultName}, {\n${namedBlock}\n} from "${moduleName}";`);
        } else {
          lines.push(`import ${typePrefix}${defaultName}, { ${namedListOrdered[0]} } from "${moduleName}";`);
        }
      } else {
        lines.push(`import ${typePrefix}${defaultName} from "${moduleName}";`);
      }
    } else if (defaultImports.length > 0 || namedImports.length > 0) {
      if (namedListOrdered.length > 1) {
        if (preferSingleLineNamed) {
          lines.push(`import ${typePrefix}{ ${namedListOrdered.join(", ")} } from "${moduleName}";`);
        } else {
          const namedBlock = namedListOrdered.map((name) => `  ${name},`).join("\n");
          lines.push(`import ${typePrefix}{\n${namedBlock}\n} from "${moduleName}";`);
        }
      } else if (namedListOrdered.length === 1) {
        lines.push(`import ${typePrefix}{ ${namedListOrdered[0]} } from "${moduleName}";`);
      }
    }

    return lines;
  }

  private getNormalizedExternalImportName(moduleName: string, importName: string): string {
    const moduleImports = this.registry.externalImports.get(moduleName);
    const externalImport = moduleImports?.get(importName);
    return externalImport?.normalizedName ?? importName;
  }

  private generateDeclarations(): string[] {
    const lines: string[] = [];
    const aliasExportedNames = this.getAliasExportedNames();

    const sorted = this.topologicalSort();
    const ordered = this.options.sortNodes
      ? [...sorted].sort((a, b) => {
          const rank = OutputGenerator.getSortRank(a) - OutputGenerator.getSortRank(b);
          if (rank !== 0) return rank;
          return a.normalizedName.localeCompare(b.normalizedName);
        })
      : sorted;

    const variableStatementGroups = new Map<
      string,
      { statement: ts.VariableStatement; declarations: TypeDeclaration[] }
    >();
    for (const declaration of ordered) {
      if (ts.isVariableStatement(declaration.node)) {
        const statement = declaration.node;
        const key = OutputGenerator.getVariableStatementKey(declaration.sourceFile, statement);
        const group = variableStatementGroups.get(key);
        if (group) {
          group.declarations.push(declaration);
        } else {
          variableStatementGroups.set(key, { statement, declarations: [declaration] });
        }
      }
    }

    const processedVariableStatements = new Set<string>();
    const exportedModuleAugmentations = new Set<string>();
    for (const declId of this.usedDeclarations) {
      const decl = this.registry.getDeclaration(declId);
      if (!decl) continue;
      if (!ts.isModuleDeclaration(decl.node)) continue;
      if (!ts.isIdentifier(decl.node.name)) continue;
      if (decl.exportInfo.kind === ExportKind.NotExported && !decl.exportInfo.wasOriginallyExported) continue;
      exportedModuleAugmentations.add(decl.node.name.text);
    }

    for (const declaration of ordered) {
      if (ts.isVariableStatement(declaration.node)) {
        const statement = declaration.node;
        const key = OutputGenerator.getVariableStatementKey(declaration.sourceFile, statement);
        if (processedVariableStatements.has(key)) {
          continue;
        }
        processedVariableStatements.add(key);
        const group = variableStatementGroups.get(key);
        if (group && this.variableDeclarationEmitter) {
          const groupLines = this.variableDeclarationEmitter.generateVariableStatementLines(
            group.statement,
            group.declarations,
          );
          if (groupLines.length > 0) {
            lines.push(...groupLines);
            continue;
          }
        }
      }

      // Keep export keyword if the declaration was originally exported or is marked as exported
      // But suppress export if this declaration is exported via export = or export default statement
      const hasDefaultModifier =
        ts.canHaveModifiers(declaration.node) &&
        (ts.getModifiers(declaration.node)?.some((mod) => mod.kind === ts.SyntaxKind.DefaultKeyword) ?? false);
      const suppressDefaultKeyword =
        (declaration.exportInfo.kind === ExportKind.Default ||
          declaration.exportInfo.kind === ExportKind.DefaultOnly) &&
        hasDefaultModifier;
      const suppressExportForModuleAugmentation =
        ts.isInterfaceDeclaration(declaration.node) && exportedModuleAugmentations.has(declaration.name);
      const stripConstEnum = this.shouldStripConstEnum(declaration);
      const suppressExportForAlias = aliasExportedNames.has(declaration.normalizedName);

      const isTypeOnlyDeclaration =
        ts.isInterfaceDeclaration(declaration.node) || ts.isTypeAliasDeclaration(declaration.node);
      const shouldExportDefaultOnlyType =
        declaration.exportInfo.kind === ExportKind.DefaultOnly && isTypeOnlyDeclaration;
      const suppressDefaultOnlyExport =
        declaration.exportInfo.kind === ExportKind.DefaultOnly && !isTypeOnlyDeclaration;
      const suppressExportKeywordForDefault =
        (declaration.exportInfo.kind === ExportKind.Default && hasDefaultModifier) || suppressDefaultOnlyExport;
      const shouldExportMergeGroup =
        declaration.mergeGroup !== null &&
        declaration.exportInfo.kind === ExportKind.NotExported &&
        !declaration.exportInfo.wasOriginallyExported;

      const shouldHaveExport =
        declaration.exportInfo.kind !== ExportKind.Equals &&
        !suppressExportKeywordForDefault &&
        !suppressExportForModuleAugmentation &&
        !suppressExportForAlias &&
        (declaration.exportInfo.kind === ExportKind.Named ||
          declaration.exportInfo.wasOriginallyExported ||
          shouldExportDefaultOnlyType ||
          shouldExportMergeGroup);

      const transformedStatement = OutputGenerator.transformStatementForOutput(
        declaration,
        shouldHaveExport,
        suppressDefaultKeyword,
        stripConstEnum,
        this.options.typeChecker,
        declaration.mergeGroup !== null,
      );
      const renameMap = this.buildRenameMap(declaration);
      const qualifiedNameMap = this.buildQualifiedNameMap(declaration);
      const namespaceImportNames = OutputGenerator.buildNamespaceImportNames(declaration);
      const printed = this.astPrinter.printStatement(transformedStatement, declaration.sourceFileNode, {
        renameMap,
        qualifiedNameMap,
        typeChecker: this.options.typeChecker,
        preserveGlobalReferences: true,
        namespaceImportNames,
        stripImportType: (node) => this.shouldStripImportType(node, declaration.sourceFileNode),
      });
      const preserveJsDoc = OutputGenerator.shouldPreserveJsDoc(declaration, shouldHaveExport);
      lines.push(normalizePrintedStatement(printed, declaration.node, declaration.getText(), { preserveJsDoc }));
    }

    return lines;
  }

  private generateNamespaces(): string[] {
    const lines: string[] = [];
    const usedNamespaces = new Map<string, { sourceFile: string; declarations: symbol[] }>();

    // Find all namespace imports that are referenced in used declarations
    for (const declId of this.usedDeclarations) {
      const decl = this.registry.getDeclaration(declId);
      if (!decl) continue;

      // Check if this declaration has namespace dependencies
      for (const namespaceName of decl.namespaceDependencies) {
        // Find the namespace info from the registry
        const key = `${decl.sourceFile}:${namespaceName}`;
        const nsInfo = this.registry.namespaceImports.get(key);

        if (nsInfo && !usedNamespaces.has(namespaceName)) {
          const valueAliases = this.namespaceValueAliasesByFile.get(decl.sourceFile);
          if (!valueAliases?.has(namespaceName)) {
            continue;
          }
          // Collect all declarations from the source file
          const fileDeclarations = this.registry.declarationsByFile.get(nsInfo.sourceFile);
          if (fileDeclarations) {
            const usedFromFile = Array.from(fileDeclarations).filter((id) => this.usedDeclarations.has(id));
            if (usedFromFile.length > 0) {
              usedNamespaces.set(namespaceName, {
                sourceFile: nsInfo.sourceFile,
                declarations: usedFromFile,
              });
            }
          }
        }
      }
    }

    // Generate namespace blocks
    for (const [namespaceName, info] of usedNamespaces.entries()) {
      lines.push(`declare namespace ${namespaceName} {`);

      for (const declId of info.declarations) {
        const declaration = this.registry.getDeclaration(declId);
        if (!declaration) continue;

        // Export the declaration within the namespace using its original name
        lines.push(`  export { ${declaration.name} };`);
      }

      lines.push(`}`);
    }

    return lines;
  }

  private shouldStripImportType(node: ts.ImportTypeNode, sourceFile: ts.SourceFile): boolean {
    const resolver = this.options.importTypeResolver;
    if (!resolver) return false;
    if (!node.qualifier) return false;

    const moduleName = OutputGenerator.getImportTypeModuleName(node);
    if (!moduleName) return false;
    if (!resolver.shouldInline(moduleName)) return false;

    const resolvedPath = resolver.resolveImport(sourceFile.fileName, moduleName);
    if (!resolvedPath) return false;

    return this.registry.declarationsByFile.has(resolvedPath);
  }

  private static getImportTypeModuleName(node: ts.ImportTypeNode): string | null {
    const argument = node.argument;
    if (!ts.isLiteralTypeNode(argument) || !ts.isStringLiteral(argument.literal)) {
      return null;
    }
    return argument.literal.text;
  }

  private generateExportEquals(): string[] {
    if (!this.options.entryExportEquals) {
      return [];
    }

    const statement = this.options.entryExportEquals;
    if (!ts.isIdentifier(statement.expression)) {
      return [];
    }

    const exportedName = statement.expression.text;
    const normalizedName = this.nameMap.get(exportedName) || exportedName;

    return [`export = ${normalizedName};`];
  }

  private generateExportDefault(): string[] {
    if (this.options.entryExportDefaultName) {
      return [this.buildDefaultExportLine(this.options.entryExportDefaultName)];
    }

    if (!this.options.entryExportDefault) {
      return [];
    }

    const statement = this.options.entryExportDefault;
    const expression = statement.expression;

    let exportedName: string;

    if (ts.isIdentifier(expression)) {
      // export default SomeIdentifier
      exportedName = expression.text;
      return [this.buildDefaultExportLine(exportedName)];
    }

    if (
      (ts.isClassDeclaration(expression) ||
        ts.isFunctionDeclaration(expression) ||
        ts.isInterfaceDeclaration(expression) ||
        ts.isEnumDeclaration(expression)) &&
      expression.name
    ) {
      // export default class/function/etc with a name
      exportedName = expression.name.text;
    } else {
      // export default <expression without name>
      return [];
    }

    const normalizedName = this.nameMap.get(exportedName) || exportedName;

    return [`export { ${normalizedName} as default };`];
  }

  private buildDefaultExportLine(exportedName: string): string {
    const normalizedName = this.nameMap.get(exportedName) || exportedName;
    const extraExports = Array.from(this.extraDefaultExports).filter((name) => name !== normalizedName);
    const exportItems = [`${normalizedName} as default`, ...extraExports];
    return `export { ${exportItems.join(", ")} };`;
  }

  private generateStarExports(): string[] {
    const lines: string[] = [];
    if (this.registry.entryStarExports.length === 0) return lines;

    const seen = new Set<string>();
    const visitedFiles = new Set<string>();

    const pushExternal = (moduleName: string, isTypeOnly = false): void => {
      const key = `${moduleName}:${isTypeOnly ? "type" : "value"}`;
      if (seen.has(key)) return;
      seen.add(key);
      const typePrefix = isTypeOnly ? "type " : "";
      lines.push(`export ${typePrefix}* from "${moduleName}";`);
    };

    const collectFromFile = (filePath: string): void => {
      if (visitedFiles.has(filePath)) return;
      visitedFiles.add(filePath);

      for (const starExport of this.registry.getStarExports(filePath)) {
        if (starExport.externalModule) {
          pushExternal(starExport.externalModule, starExport.isTypeOnly ?? false);
        } else if (starExport.targetFile) {
          collectFromFile(starExport.targetFile);
        }
      }
    };

    for (const entry of this.registry.entryStarExports) {
      if (entry.info.externalModule) {
        pushExternal(entry.info.externalModule, entry.info.isTypeOnly ?? false);
      } else if (entry.info.targetFile) {
        collectFromFile(entry.info.targetFile);
      }
    }

    return lines;
  }

  private generateNamespaceExports(): { blocks: string[]; exportList: string[] } {
    const blocks: string[] = [];
    const exportNames: string[] = [];

    if (this.registry.entryNamespaceExports.length === 0) {
      return { blocks, exportList: [] };
    }

    const depthCache = new Map<string, number>();
    const entryExports = this.registry.entryNamespaceExports.map((entry) => ({
      entry,
      depth: this.getNamespaceExportDepth(entry, depthCache),
    }));

    entryExports.sort((a, b) => b.depth - a.depth);

    const visited = new Set<string>();
    for (const { entry } of entryExports) {
      const info = this.registry.getNamespaceExportInfo(entry.sourceFile, entry.name);
      if (!info) continue;
      this.buildNamespaceBlocks(entry.sourceFile, entry.name, info, visited, blocks);
    }

    for (const entry of this.registry.entryNamespaceExports) {
      exportNames.push(entry.name);
    }

    const exportList = exportNames.length > 0 ? [`export { ${exportNames.join(", ")} };`] : [];
    return { blocks, exportList };
  }

  private buildNamespaceBlocks(
    sourceFile: string,
    namespaceName: string,
    info: { targetFile?: string; externalModule?: string; externalImportName?: string },
    visited: Set<string>,
    blocks: string[],
  ): void {
    const key = `${sourceFile}:${namespaceName}`;
    if (visited.has(key)) return;
    visited.add(key);

    if (!info.targetFile) {
      return;
    }

    const exportedNames = this.registry.exportedNamesByFile.get(info.targetFile) ?? [];

    for (const exported of exportedNames) {
      const childInfo = this.registry.getNamespaceExportInfo(info.targetFile, exported.name);
      if (childInfo && childInfo.targetFile) {
        this.buildNamespaceBlocks(info.targetFile, exported.name, childInfo, visited, blocks);
      }
    }

    const exportList = exportedNames.map((item) => item.name);
    blocks.push(`declare namespace ${namespaceName} {`);
    if (exportList.length > 0) {
      blocks.push(`  export { ${exportList.join(", ")} };`);
    }
    blocks.push(`}`);
  }

  private getNamespaceExportDepth(
    entry: { name: string; sourceFile: string },
    depthCache: Map<string, number>,
  ): number {
    const key = `${entry.sourceFile}:${entry.name}`;
    if (depthCache.has(key)) return depthCache.get(key) as number;

    const info = this.registry.getNamespaceExportInfo(entry.sourceFile, entry.name);
    if (!info || !info.targetFile) {
      depthCache.set(key, 1);
      return 1;
    }

    const exportedNames = this.registry.exportedNamesByFile.get(info.targetFile) ?? [];
    let maxChild = 0;
    for (const exported of exportedNames) {
      const childInfo = this.registry.getNamespaceExportInfo(info.targetFile, exported.name);
      if (childInfo && childInfo.targetFile) {
        const childDepth = this.getNamespaceExportDepth(
          { name: exported.name, sourceFile: info.targetFile },
          depthCache,
        );
        if (childDepth > maxChild) {
          maxChild = childDepth;
        }
      }
    }

    const depth = 1 + maxChild;
    depthCache.set(key, depth);
    return depth;
  }

  /* eslint-disable no-param-reassign */
  private static stripExportModifier(text: string): string {
    // Strip both "export default" and "export", handling leading whitespace
    text = text.replace(/export\s+default\s+/, "");
    text = text.replace(/export\s+/, "");
    return text;
  }
  /* eslint-enable no-param-reassign */

  private static addDeclareKeyword(text: string): string {
    // Only add declare to class, enum, function, namespace, and module (not interface or type)
    // Handle both "export class" and "class" patterns
    const match = text.match(
      /^((?:\s*(?:\/\*[\s\S]*?\*\/\s*|\/\/[^\n]*\n\s*)*)(?:export\s+)?)(class|enum|function|namespace|module)(?:\s|$)/,
    );
    if (match) {
      const prefix = match[1]; // comments and export keyword
      const declarationKeyword = match[2]; // class, enum, or function
      const rest = text.substring(match[0].length - 1); // everything after the keyword
      return `${prefix}declare ${declarationKeyword}${rest}`;
    }
    return text;
  }

  private static stripNamespaceMemberExports(text: string): string {
    const openBraceIndex = text.indexOf("{");
    const closeBraceIndex = text.lastIndexOf("}");
    if (openBraceIndex === -1 || closeBraceIndex === -1 || closeBraceIndex <= openBraceIndex) {
      return text;
    }

    const prefix = text.slice(0, openBraceIndex + 1);
    const body = text.slice(openBraceIndex + 1, closeBraceIndex);
    const suffix = text.slice(closeBraceIndex);

    const cleanedBody = body.replace(
      /(^|\n)(\s*)export\s+(?=(?:declare\s+)?(?:namespace|module|interface|type|class|enum|const|let|var|function)\b)/g,
      "$1$2",
    );

    return `${prefix}${cleanedBody}${suffix}`;
  }

  private static stripDeclareGlobalMemberExports(text: string): string {
    const openBraceIndex = text.indexOf("{");
    const closeBraceIndex = text.lastIndexOf("}");
    if (openBraceIndex === -1 || closeBraceIndex === -1 || closeBraceIndex <= openBraceIndex) {
      return text;
    }

    const prefix = text.slice(0, openBraceIndex + 1);
    const body = text.slice(openBraceIndex + 1, closeBraceIndex);
    const suffix = text.slice(closeBraceIndex);

    const cleanedBody = body.replace(
      /(^|\n)(\s*)export\s+(?=(?:declare\s+)?(?:interface|type|class|enum|const|let|var|function)\b)/g,
      "$1$2",
    );

    return `${prefix}${cleanedBody}${suffix}`;
  }

  /* eslint-disable no-param-reassign */
  private static stripImplementationDetails(text: string): string {
    // Strip public/private/protected modifiers from class members
    text = text.replace(/^(\s*)(public|private|protected)\s+/gm, "$1");

    // Strip property initializers (e.g., field: string = ""; becomes field: string;)
    // This should match property declarations (not methods) with initializers
    // Property pattern: identifier : type = value;
    // Avoid matching methods which have () in their signature
    text = text.replace(/^(\s*)([a-zA-Z_$][\w$]*)\s*:\s*([^;=()]+?)\s*=\s*[^;]+;/gm, "$1$2: $3;");

    // Strip function bodies - replace { ... } with just semicolon
    text = text.replace(/^((?:export\s+)?(?:declare\s+)?function\s+[^{]+?)\s*\{[^}]*\}/gm, "$1;");

    return text;
  }
  /* eslint-enable no-param-reassign */

  private static getVariableStatementKey(sourceFile: string, statement: ts.VariableStatement): string {
    return `${sourceFile}:${statement.pos}:${statement.end}`;
  }

  private topologicalSort(): TypeDeclaration[] {
    const sorted: TypeDeclaration[] = [];
    const visited = new Set<symbol>();
    const visiting = new Set<symbol>();

    const isExportEqualsFile = (declaration: TypeDeclaration): boolean =>
      declaration.sourceFileNode.statements.some(
        (statement) => ts.isExportAssignment(statement) && statement.isExportEquals,
      );

    const visit = (id: symbol): void => {
      if (visited.has(id)) return;
      if (visiting.has(id)) {
        return;
      }

      visiting.add(id);
      const declaration = this.registry.getDeclaration(id);

      if (declaration) {
        for (const depId of declaration.dependencies) {
          if (this.usedDeclarations.has(depId)) {
            visit(depId);
          }
        }

        visiting.delete(id);
        visited.add(id);
        sorted.push(declaration);
      }
    };

    const used = Array.from(this.usedDeclarations);
    const entryImportedFiles = this.options.entryImportedFiles ?? new Set<string>();
    const indexById = new Map<symbol, number>();
    used.forEach((id, index) => indexById.set(id, index));

    const ordered = [...used].sort((a, b) => {
      const declA = this.registry.getDeclaration(a);
      const declB = this.registry.getDeclaration(b);
      if (!declA || !declB) return 0;

      const aEntry = entryImportedFiles.has(declA.sourceFile);
      const bEntry = entryImportedFiles.has(declB.sourceFile);
      if (aEntry !== bEntry) return aEntry ? -1 : 1;

      const aExported = declA.exportInfo.kind !== ExportKind.NotExported || isExportEqualsFile(declA);
      const bExported = declB.exportInfo.kind !== ExportKind.NotExported || isExportEqualsFile(declB);
      if (aExported !== bExported) return aExported ? 1 : -1;

      return (indexById.get(a) ?? 0) - (indexById.get(b) ?? 0);
    });

    // Ordering adjustments are handled after sorting.

    for (const id of ordered) {
      visit(id);
    }

    return this.adjustDeclarationOrderByFile(sorted);
  }

  private adjustDeclarationOrderByFile(declarations: TypeDeclaration[]): TypeDeclaration[] {
    if (declarations.length === 0) {
      return declarations;
    }

    const entryFile = this.options.entryFile;
    const byFile = new Map<string, TypeDeclaration[]>();
    for (const decl of declarations) {
      const list = byFile.get(decl.sourceFile) ?? [];
      list.push(decl);
      byFile.set(decl.sourceFile, list);
    }

    const defaultExportAssignmentFiles = new Set<string>();
    for (const [file, list] of byFile.entries()) {
      if (entryFile && file === entryFile) {
        continue;
      }
      const sourceFileNode = list[0].sourceFileNode;
      const hasDefaultExportAssignment = sourceFileNode.statements.some(
        (statement) =>
          ts.isExportAssignment(statement) && !statement.isExportEquals && ts.isIdentifier(statement.expression),
      );
      if (hasDefaultExportAssignment) {
        defaultExportAssignmentFiles.add(file);
      }
    }

    if (defaultExportAssignmentFiles.size === 0) {
      return declarations;
    }

    const result: TypeDeclaration[] = [];
    for (const decl of declarations) {
      if (!defaultExportAssignmentFiles.has(decl.sourceFile)) {
        result.push(decl);
        continue;
      }

      const list = byFile.get(decl.sourceFile);
      if (!list || list.length === 0) continue;

      const sortedList = [...list].sort((a, b) => {
        const posDiff = a.node.pos - b.node.pos;
        if (posDiff !== 0) return posDiff;
        return declarations.indexOf(a) - declarations.indexOf(b);
      });

      result.push(...sortedList);
      list.length = 0;
    }

    return result;
  }

  private buildRenameMap(declaration: TypeDeclaration): Map<string, string> {
    const renameMap = new Map<string, string>();

    if (declaration.name !== declaration.normalizedName) {
      renameMap.set(declaration.name, declaration.normalizedName);
    }

    for (const depId of declaration.dependencies) {
      const depDecl = this.registry.getDeclaration(depId);
      if (depDecl && depDecl.name !== depDecl.normalizedName) {
        renameMap.set(depDecl.name, depDecl.normalizedName);
      }
    }

    for (const [moduleName, importNames] of declaration.externalDependencies.entries()) {
      const moduleImports = this.registry.externalImports.get(moduleName);
      if (!moduleImports) continue;

      for (const importName of importNames) {
        const externalImport = moduleImports.get(importName);
        if (!externalImport) continue;

        const originalName = OutputGenerator.extractImportName(externalImport.originalName);
        const normalizedName = OutputGenerator.extractImportName(externalImport.normalizedName);

        if (originalName !== normalizedName) {
          renameMap.set(originalName, normalizedName);
        }
      }
    }

    for (const [alias, info] of declaration.importAliases.entries()) {
      if (info.qualifiedName) {
        const parts = info.qualifiedName.split(".");
        const root = parts[0];
        const key = `${info.sourceFile}:${root}`;
        const depId = this.registry.getFirstDeclarationIdByKey(key);
        const depDecl = depId ? this.registry.getDeclaration(depId) : null;
        const normalizedRoot = depDecl?.normalizedName ?? root;
        const normalizedQualified = [normalizedRoot, ...parts.slice(1)].join(".");
        if (alias !== normalizedQualified) {
          renameMap.set(alias, normalizedQualified);
        }
        continue;
      }

      const key = `${info.sourceFile}:${info.originalName}`;
      const depId = this.registry.getFirstDeclarationIdByKey(key);
      if (!depId) continue;
      const depDecl = this.registry.getDeclaration(depId);
      if (!depDecl) continue;
      const normalized = depDecl.normalizedName;
      if (alias !== normalized) {
        renameMap.set(alias, normalized);
      }
    }

    const localRefs = OutputGenerator.collectLocalTypeReferences(declaration.node);
    for (const refName of localRefs) {
      const localId = this.registry.getFirstDeclarationIdByKey(`${declaration.sourceFile}:${refName}`);
      if (!localId) continue;
      const localDecl = this.registry.getDeclaration(localId);
      if (!localDecl) continue;
      if (localDecl.name !== localDecl.normalizedName) {
        renameMap.set(localDecl.name, localDecl.normalizedName);
      }
    }

    return renameMap;
  }

  private static collectLocalTypeReferences(node: ts.Node): Set<string> {
    const refs = new Set<string>();

    const visit = (current: ts.Node): void => {
      if (ts.isTypeReferenceNode(current)) {
        const typeName = current.typeName;
        if (ts.isIdentifier(typeName)) {
          refs.add(typeName.text);
        } else if (ts.isQualifiedName(typeName)) {
          const leftmost = OutputGenerator.getLeftmostEntityName(typeName);
          if (leftmost) refs.add(leftmost);
        }
      }

      if (ts.isTypeQueryNode(current)) {
        const leftmost = OutputGenerator.getLeftmostEntityName(current.exprName);
        if (leftmost) refs.add(leftmost);
      }

      current.forEachChild(visit);
    };

    visit(node);
    return refs;
  }

  private buildRenameMapForDeclarations(declarations: TypeDeclaration[]): Map<string, string> {
    const merged = new Map<string, string>();
    for (const declaration of declarations) {
      for (const [name, normalized] of this.buildRenameMap(declaration)) {
        merged.set(name, normalized);
      }
    }

    return merged;
  }

  private getAliasExportedNames(): Set<string> {
    const aliasNames = new Set<string>();
    const { exportListItems } = this.getEntryExportData();
    for (const item of exportListItems) {
      const parts = item.split(" as ");
      if (parts.length === 2) {
        aliasNames.add(parts[0].trim());
      }
    }
    return aliasNames;
  }

  private static buildNamespaceImportNames(declaration: TypeDeclaration): Set<string> {
    const names = new Set<string>();
    for (const importNames of declaration.externalDependencies.values()) {
      for (const importName of importNames) {
        if (importName.startsWith("* as ")) {
          names.add(OutputGenerator.extractImportName(importName));
        }
      }
    }
    return names;
  }

  private buildQualifiedNameMap(declaration: TypeDeclaration): Map<string, string> {
    const qualifiedNameMap = new Map<string, string>();
    const valueAliases = this.namespaceValueAliasesByFile.get(declaration.sourceFile) ?? new Set<string>();

    for (const [key, nsInfo] of this.registry.namespaceImports.entries()) {
      const split = OutputGenerator.splitNamespaceKey(key);
      if (split.filePath !== declaration.sourceFile) continue;
      if (valueAliases.has(nsInfo.namespaceName)) continue;

      const fileDeclarations = this.registry.declarationsByFile.get(nsInfo.sourceFile);
      if (fileDeclarations) {
        for (const declId of fileDeclarations) {
          const depDecl = this.registry.getDeclaration(declId);
          if (!depDecl) continue;
          const mapKey = `${nsInfo.namespaceName}.${depDecl.name}`;
          qualifiedNameMap.set(mapKey, depDecl.normalizedName);
        }
      }

      const defaultName = this.getDefaultExportName(nsInfo.sourceFile);
      if (defaultName) {
        const defaultId = this.registry.getFirstDeclarationIdByKey(`${nsInfo.sourceFile}:${defaultName}`);
        const defaultDecl = defaultId ? this.registry.getDeclaration(defaultId) : null;
        const normalizedDefault = defaultDecl?.normalizedName ?? defaultName;
        qualifiedNameMap.set(`${nsInfo.namespaceName}.default`, normalizedDefault);
      }
    }

    return qualifiedNameMap;
  }

  private collectNamespaceValueAliases(): Map<string, Set<string>> {
    const aliasesByFile = new Map<string, Set<string>>();
    for (const [key, info] of this.registry.namespaceImports.entries()) {
      const split = OutputGenerator.splitNamespaceKey(key);
      const set = aliasesByFile.get(split.filePath) ?? new Set<string>();
      set.add(info.namespaceName);
      aliasesByFile.set(split.filePath, set);
    }

    const valueAliasesByFile = new Map<string, Set<string>>();
    for (const declId of this.usedDeclarations) {
      const declaration = this.registry.getDeclaration(declId);
      if (!declaration) continue;
      const namespaceAliases = aliasesByFile.get(declaration.sourceFile);
      if (!namespaceAliases || namespaceAliases.size === 0) continue;

      const valueAliases = valueAliasesByFile.get(declaration.sourceFile) ?? new Set<string>();
      const visit = (node: ts.Node): void => {
        if (ts.isVariableDeclaration(node) && node.initializer && ts.isIdentifier(node.initializer)) {
          const name = node.initializer.text;
          if (namespaceAliases.has(name)) {
            valueAliases.add(name);
          }
        }

        if (ts.isTypeQueryNode(node)) {
          const exprName = node.exprName;
          const leftmost = OutputGenerator.getLeftmostEntityName(exprName);
          if (leftmost && namespaceAliases.has(leftmost)) {
            valueAliases.add(leftmost);
          }
        }

        node.forEachChild(visit);
      };

      visit(declaration.node);
      if (valueAliases.size > 0) {
        valueAliasesByFile.set(declaration.sourceFile, valueAliases);
      }
    }

    return valueAliasesByFile;
  }

  private static splitNamespaceKey(key: string): { filePath: string; namespaceName: string } {
    const splitIndex = key.lastIndexOf(":");
    return {
      filePath: key.slice(0, splitIndex),
      namespaceName: key.slice(splitIndex + 1),
    };
  }

  private static getLeftmostEntityName(entity: ts.EntityName): string | null {
    let current: ts.EntityName = entity;
    while (ts.isQualifiedName(current)) {
      current = current.left;
    }
    return ts.isIdentifier(current) ? current.text : null;
  }

  private getDefaultExportName(filePath: string): string | null {
    const declarations = this.registry.declarationsByFile.get(filePath);
    if (!declarations) return null;

    for (const declId of declarations) {
      const decl = this.registry.getDeclaration(declId);
      if (!decl) continue;
      if (decl.exportInfo.kind === ExportKind.Default || decl.exportInfo.kind === ExportKind.DefaultOnly) {
        return decl.name;
      }
      if (ts.isStatement(decl.node) && ts.canHaveModifiers(decl.node)) {
        const hasDefault = ts.getModifiers(decl.node)?.some((mod) => mod.kind === ts.SyntaxKind.DefaultKeyword);
        if (hasDefault) {
          return decl.name;
        }
      }
    }

    return null;
  }

  private static extractImportName(importStr: string): string {
    if (importStr.startsWith("default as ")) {
      return importStr.replace("default as ", "");
    }
    if (importStr.startsWith("* as ")) {
      return importStr.replace("* as ", "");
    }
    if (importStr.includes(" as ")) {
      const parts = importStr.split(" as ");
      return parts[1].trim();
    }
    return importStr;
  }

  private static getSortRank(declaration: TypeDeclaration): number {
    const node = declaration.node;
    if (ts.isInterfaceDeclaration(node)) return 1;
    if (ts.isTypeAliasDeclaration(node)) return 2;
    if (ts.isClassDeclaration(node)) return 3;
    if (ts.isEnumDeclaration(node)) return 4;
    if (ts.isModuleDeclaration(node)) return 5;
    return 10;
  }

  private generateReferenceDirectives(): string[] {
    const directives: string[] = [];
    const { referencedTypes, allowedTypesLibraries, detectedTypesLibraries } = this.options;
    const typesToReference = new Set<string>();

    if (referencedTypes && allowedTypesLibraries) {
      for (const typeName of referencedTypes) {
        if (allowedTypesLibraries.includes(typeName)) {
          typesToReference.add(typeName);
        }
      }
    }

    if (detectedTypesLibraries) {
      for (const typeName of detectedTypesLibraries) {
        if (!allowedTypesLibraries || allowedTypesLibraries.includes(typeName)) {
          typesToReference.add(typeName);
        }
      }
    }

    const sortedTypes = Array.from(typesToReference).sort();
    for (const typeName of sortedTypes) {
      directives.push(`/// <reference types="${typeName}" />`);
    }

    return directives;
  }

  private static transformStatementForOutput(
    declaration: TypeDeclaration,
    shouldHaveExport: boolean,
    suppressExportForDefault: boolean,
    stripConstEnum: boolean,
    typeChecker?: ts.TypeChecker,
    forceExport = false,
  ): ts.Statement {
    let statement = declaration.node as ts.Statement;
    const modifiersMap = modifiersToMap(getModifiers(statement));
    const hadExport = Boolean(modifiersMap[ts.SyntaxKind.ExportKeyword]);
    const shouldForceExport = shouldHaveExport && (forceExport || OutputGenerator.shouldForceExport(statement));
    const shouldExportDefaultOnlyType =
      declaration.exportInfo.kind === ExportKind.DefaultOnly &&
      (ts.isInterfaceDeclaration(statement) || ts.isTypeAliasDeclaration(statement));
    const shouldAddExport = shouldHaveExport && (hadExport || shouldForceExport || shouldExportDefaultOnlyType);
    modifiersMap[ts.SyntaxKind.ExportKeyword] = shouldAddExport;
    if (suppressExportForDefault) {
      modifiersMap[ts.SyntaxKind.DefaultKeyword] = false;
    }

    if (ts.isEnumDeclaration(statement) && typeChecker) {
      let nextNumericValue: number | null = 0;
      const members = statement.members.map((member) => {
        if (member.initializer) {
          if (ts.isNumericLiteral(member.initializer)) {
            nextNumericValue = Number(member.initializer.text) + 1;
          } else {
            nextNumericValue = null;
          }
          return member;
        }

        const value = typeChecker.getConstantValue(member);
        if (value !== undefined) {
          const initializer =
            typeof value === "number"
              ? ts.factory.createNumericLiteral(value)
              : ts.factory.createStringLiteral(String(value));
          if (typeof value === "number") {
            nextNumericValue = value + 1;
          } else {
            nextNumericValue = null;
          }
          const updated = ts.factory.updateEnumMember(member, member.name, initializer);
          ts.setTextRange(updated, member);
          return updated;
        }

        if (nextNumericValue !== null) {
          const initializer = ts.factory.createNumericLiteral(nextNumericValue);
          nextNumericValue += 1;
          const updated = ts.factory.updateEnumMember(member, member.name, initializer);
          ts.setTextRange(updated, member);
          return updated;
        }

        return member;
      });

      statement = ts.factory.updateEnumDeclaration(statement, statement.modifiers, statement.name, members);
    }

    if (ts.isFunctionDeclaration(statement) && !statement.type) {
      const isDefaultExport =
        declaration.exportInfo.kind === ExportKind.Default || declaration.exportInfo.kind === ExportKind.DefaultOnly;
      if (!isDefaultExport) {
        const updated = ts.factory.updateFunctionDeclaration(
          statement,
          statement.modifiers,
          statement.asteriskToken,
          statement.name,
          statement.typeParameters,
          statement.parameters,
          ts.factory.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword),
          statement.body,
        );
        ts.setTextRange(updated, statement);
        statement = updated;
      }
    }

    if (stripConstEnum) {
      modifiersMap[ts.SyntaxKind.ConstKeyword] = false;
    }

    // Add declare keyword when:
    // 1. The statement is from a .ts file (not a .d.ts file), OR
    // 2. We're stripping the export keyword from a .d.ts file declaration
    const strippingExport = hadExport && !shouldAddExport;
    if (OutputGenerator.shouldAddDeclareKeyword(statement, strippingExport)) {
      modifiersMap[ts.SyntaxKind.DeclareKeyword] = true;
    }

    statement = recreateRootLevelNodeWithModifiers(statement, modifiersMap) as ts.Statement;

    const result = ts.transform(statement, [OutputGenerator.createOutputTransformer()]);
    const transformed = result.transformed[0] as ts.Statement;
    result.dispose();
    return transformed;
  }

  private static createOutputTransformer(): ts.TransformerFactory<ts.Statement> {
    return (context) => {
      const visit: ts.Visitor = (node) => {
        if (ts.isParameter(node) && node.initializer) {
          const questionToken = node.questionToken ?? ts.factory.createToken(ts.SyntaxKind.QuestionToken);
          const updated = ts.factory.updateParameterDeclaration(
            node,
            node.modifiers,
            node.dotDotDotToken,
            node.name,
            questionToken,
            node.type,
            undefined,
          );
          ts.setTextRange(updated, node);
          return updated;
        }

        if (OutputGenerator.shouldStripNamespaceMemberExport(node)) {
          return OutputGenerator.stripExportFromStatement(node as ts.Statement, false);
        }

        if (ts.isFunctionDeclaration(node) && node.body) {
          const parameters = node.parameters.map((parameter) => OutputGenerator.stripParameterInitializer(parameter));
          const updated = ts.factory.updateFunctionDeclaration(
            node,
            node.modifiers,
            node.asteriskToken,
            node.name,
            node.typeParameters,
            parameters,
            node.type,
            undefined,
          );
          ts.setTextRange(updated, node);
          return updated;
        }

        if (ts.isClassDeclaration(node)) {
          const members = node.members.map((member) => OutputGenerator.stripClassMemberImplementation(member));
          const updated = ts.factory.updateClassDeclaration(
            node,
            node.modifiers,
            node.name,
            node.typeParameters,
            node.heritageClauses,
            members,
          );
          ts.setTextRange(updated, node);
          return updated;
        }

        if (ts.isModuleDeclaration(node)) {
          // eslint-disable-next-line no-bitwise
          const isDeclareGlobal = (node.flags & ts.NodeFlags.GlobalAugmentation) !== 0;
          const isExternalModule = ts.isStringLiteral(node.name) || ts.isNoSubstitutionTemplateLiteral(node.name);
          let body = node.body;
          if (body && ts.isModuleBlock(body)) {
            const statements = isExternalModule
              ? body.statements
              : body.statements.map((statement) =>
                  OutputGenerator.stripExportFromStatement(statement, isDeclareGlobal),
                );
            body = ts.factory.updateModuleBlock(body, statements);
          }

          let flags = node.flags;
          if (!isDeclareGlobal && ts.isIdentifier(node.name) && OutputGenerator.isNamespaceDeclaration(node)) {
            // eslint-disable-next-line no-bitwise
            flags |= ts.NodeFlags.Namespace;
          }

          const updated = ts.factory.createModuleDeclaration(node.modifiers, node.name, body, flags);
          ts.setTextRange(updated, node);
          return ts.visitEachChild(updated, visit, context);
        }

        return ts.visitEachChild(node, visit, context);
      };

      return (rootNode) => ts.visitNode(rootNode, visit) as ts.Statement;
    };
  }

  private static stripClassMemberImplementation(member: ts.ClassElement): ts.ClassElement {
    const modifiers = getModifiers(member);
    if (ts.isPropertyDeclaration(member)) {
      const filteredModifiers = OutputGenerator.stripAccessModifiers(modifiers);
      const updated = ts.factory.updatePropertyDeclaration(
        member,
        filteredModifiers,
        member.name,
        member.questionToken ?? member.exclamationToken,
        member.type,
        undefined,
      );
      ts.setTextRange(updated, member);
      return updated;
    }

    if (modifiers) {
      const filteredModifiers = OutputGenerator.stripAccessModifiers(modifiers);
      if (filteredModifiers !== modifiers) {
        if (ts.isMethodDeclaration(member)) {
          const parameters = member.parameters.map((parameter) => OutputGenerator.stripParameterInitializer(parameter));
          const updated = ts.factory.updateMethodDeclaration(
            member,
            filteredModifiers,
            member.asteriskToken,
            member.name,
            member.questionToken,
            member.typeParameters,
            parameters,
            member.type,
            undefined,
          );
          ts.setTextRange(updated, member);
          return updated;
        }
      }

      if (ts.isMethodDeclaration(member) && member.body) {
        const parameters = member.parameters.map((parameter) => OutputGenerator.stripParameterInitializer(parameter));
        const updated = ts.factory.updateMethodDeclaration(
          member,
          filteredModifiers,
          member.asteriskToken,
          member.name,
          member.questionToken,
          member.typeParameters,
          parameters,
          member.type,
          undefined,
        );
        ts.setTextRange(updated, member);
        return updated;
      }

      if (ts.isConstructorDeclaration(member) && member.body) {
        const parameters = member.parameters.map((parameter) => OutputGenerator.stripParameterInitializer(parameter));
        const updated = ts.factory.updateConstructorDeclaration(member, filteredModifiers, parameters, undefined);
        ts.setTextRange(updated, member);
        return updated;
      }

      if (ts.isGetAccessorDeclaration(member) && member.body) {
        const updated = ts.factory.updateGetAccessorDeclaration(
          member,
          filteredModifiers,
          member.name,
          member.parameters.map((parameter) => OutputGenerator.stripParameterInitializer(parameter)),
          member.type,
          undefined,
        );
        ts.setTextRange(updated, member);
        return updated;
      }

      if (ts.isSetAccessorDeclaration(member) && member.body) {
        const updated = ts.factory.updateSetAccessorDeclaration(
          member,
          filteredModifiers,
          member.name,
          member.parameters.map((parameter) => OutputGenerator.stripParameterInitializer(parameter)),
          undefined,
        );
        ts.setTextRange(updated, member);
        return updated;
      }
    }

    return member;
  }

  private static stripParameterInitializer(parameter: ts.ParameterDeclaration): ts.ParameterDeclaration {
    if (!parameter.initializer) {
      return parameter;
    }

    const questionToken = parameter.questionToken ?? ts.factory.createToken(ts.SyntaxKind.QuestionToken);
    const updated = ts.factory.updateParameterDeclaration(
      parameter,
      parameter.modifiers,
      parameter.dotDotDotToken,
      parameter.name,
      questionToken,
      parameter.type,
      undefined,
    );
    ts.setTextRange(updated, parameter);
    return updated;
  }

  private static stripExportFromStatement(statement: ts.Statement, preserveNamespaceExport: boolean): ts.Statement {
    if (preserveNamespaceExport && ts.isModuleDeclaration(statement)) {
      return statement;
    }

    const modifiers = getModifiers(statement);
    if (!modifiers) {
      return statement;
    }

    const modifiersMap = modifiersToMap(modifiers);
    if (!modifiersMap[ts.SyntaxKind.ExportKeyword]) {
      return statement;
    }

    modifiersMap[ts.SyntaxKind.ExportKeyword] = false;
    return recreateRootLevelNodeWithModifiers(statement, modifiersMap) as ts.Statement;
  }

  private static shouldStripNamespaceMemberExport(node: ts.Node): boolean {
    if (!ts.isStatement(node)) {
      return false;
    }

    const parentBlock = (node as Omit<ts.Node, "parent"> & { parent?: ts.Node }).parent;
    if (!parentBlock) {
      return false;
    }
    if (!ts.isModuleBlock(parentBlock)) {
      return false;
    }

    const moduleDecl = parentBlock.parent;
    if (!ts.isModuleDeclaration(moduleDecl)) {
      return false;
    }

    const isExternalModule = ts.isStringLiteral(moduleDecl.name) || ts.isNoSubstitutionTemplateLiteral(moduleDecl.name);
    if (isExternalModule) {
      return false;
    }

    return !ts.isModuleDeclaration(node);
  }

  private static isConstEnumDeclaration(node: ts.Node): boolean {
    if (!ts.isEnumDeclaration(node) || !ts.canHaveModifiers(node)) {
      return false;
    }

    return ts.getModifiers(node)?.some((mod) => mod.kind === ts.SyntaxKind.ConstKeyword) ?? false;
  }

  private static shouldPreserveJsDoc(declaration: TypeDeclaration, shouldHaveExport: boolean): boolean {
    if (shouldHaveExport) {
      return true;
    }

    if (declaration.exportInfo.wasOriginallyExported) {
      return true;
    }

    if (declaration.exportInfo.kind === ExportKind.Default || declaration.exportInfo.kind === ExportKind.DefaultOnly) {
      return true;
    }

    if (OutputGenerator.isConstEnumDeclaration(declaration.node)) {
      return true;
    }

    return ts.isInterfaceDeclaration(declaration.node) || ts.isTypeAliasDeclaration(declaration.node);
  }

  private static shouldAddDeclareKeyword(statement: ts.Statement, strippingExport: boolean): boolean {
    // Only these statement types need a declare keyword at top level
    const needsDeclareKeyword =
      ts.isClassDeclaration(statement) ||
      ts.isEnumDeclaration(statement) ||
      ts.isFunctionDeclaration(statement) ||
      ts.isModuleDeclaration(statement);

    if (!needsDeclareKeyword) {
      return false;
    }

    const sourceFile = statement.getSourceFile();
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (!sourceFile) {
      return true;
    }

    // For .d.ts files: only add declare if we're stripping the export keyword
    // (non-exported declarations in .d.ts files need declare to be valid at top level)
    if (sourceFile.isDeclarationFile) {
      return strippingExport;
    }

    // For .ts files: always add declare
    return true;
  }

  private static isNamespaceDeclaration(node: ts.ModuleDeclaration): boolean {
    const sourceFile = node.getSourceFile();
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (!sourceFile) {
      return false;
    }

    const text = sourceFile.text.slice(node.pos, node.end);
    const header = text.split("{")[0] ?? text;
    if (/\bdeclare\s+module\b/.test(header)) {
      return false;
    }

    return /\bnamespace\b/.test(header) || /\bmodule\b/.test(header);
  }

  private static shouldForceExport(statement: ts.Statement): boolean {
    if (!ts.isModuleDeclaration(statement)) {
      return false;
    }

    if (!ts.isIdentifier(statement.name)) {
      return false;
    }

    if (OutputGenerator.isNamespaceDeclaration(statement)) {
      return false;
    }

    // eslint-disable-next-line no-bitwise
    if ((statement.flags & ts.NodeFlags.GlobalAugmentation) !== 0) {
      return false;
    }

    return true;
  }

  private shouldStripConstEnum(declaration: TypeDeclaration): boolean {
    if (!this.options.preserveConstEnums || !this.options.respectPreserveConstEnum) {
      return false;
    }

    if (!ts.isEnumDeclaration(declaration.node)) {
      return false;
    }

    const modifiers = getModifiers(declaration.node);
    const hasConst = modifiers?.some((mod) => mod.kind === ts.SyntaxKind.ConstKeyword) ?? false;
    if (!hasConst) {
      return false;
    }

    return declaration.exportInfo.kind !== ExportKind.NotExported && declaration.exportInfo.wasOriginallyExported;
  }

  private static stripAccessModifiers(
    modifiers: readonly ts.Modifier[] | undefined,
  ): readonly ts.Modifier[] | undefined {
    if (!modifiers || modifiers.length === 0) {
      return modifiers;
    }

    const filtered = modifiers.filter(
      (modifier) =>
        modifier.kind !== ts.SyntaxKind.PublicKeyword &&
        modifier.kind !== ts.SyntaxKind.PrivateKeyword &&
        modifier.kind !== ts.SyntaxKind.ProtectedKeyword,
    );

    return filtered.length === modifiers.length ? modifiers : filtered;
  }
}
