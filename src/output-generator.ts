import ts from "typescript";
import pkg from "../package.json" assert { type: "json" };
import type { TypeRegistry } from "./registry.js";
import type { ExternalImport, TypeDeclaration } from "./types.js";

const version = (pkg as { version?: string }).version ?? "development";

export class OutputGenerator {
  private registry: TypeRegistry;
  private usedDeclarations: Set<symbol>;
  private usedExternals: Map<string, Set<ExternalImport>>;
  private nameMap: Map<string, string>;
  private options: {
    noBanner?: boolean;
    sortNodes?: boolean;
    umdModuleName?: string;
    includeEmptyExport?: boolean;
    allowedTypesLibraries?: string[];
    importedLibraries?: string[];
    referencedTypes?: Set<string>;
  };

  constructor(
    registry: TypeRegistry,
    usedDeclarations: Set<symbol>,
    usedExternals: Map<string, Set<ExternalImport>>,
    options: {
      noBanner?: boolean;
      sortNodes?: boolean;
      umdModuleName?: string;
      includeEmptyExport?: boolean;
      allowedTypesLibraries?: string[];
      importedLibraries?: string[];
      referencedTypes?: Set<string>;
    } = {},
  ) {
    this.registry = registry;
    this.usedDeclarations = usedDeclarations;
    this.usedExternals = usedExternals;
    this.nameMap = new Map();
    this.options = options;
  }

  generate(): string {
    const lines: string[] = [];

    const banner = !this.options.noBanner ? `// Generated by @qlik/dts-bundler@${version}` : null;
    const referenceDirectives = this.generateReferenceDirectives();
    const externalImports = this.usedExternals.size > 0 ? this.generateExternalImports() : [];

    this.buildNameMap();
    const declarations = this.generateDeclarations();

    const umdDeclaration = this.options.umdModuleName ? [`export as namespace ${this.options.umdModuleName};`] : [];
    const emptyExport = this.options.includeEmptyExport ? ["export {};"] : [];

    const appendSection = (section: string[]): void => {
      if (section.length === 0) return;
      if (lines.length > 0) lines.push("");
      lines.push(...section);
    };

    if (banner) {
      lines.push(banner);
    }

    appendSection(referenceDirectives);
    appendSection(externalImports);
    appendSection(declarations);
    appendSection(umdDeclaration);
    appendSection(emptyExport);

    return `${lines.join("\n")}\n`;
  }

  private buildNameMap(): void {
    for (const id of this.usedDeclarations) {
      const declaration = this.registry.getDeclaration(id);
      if (declaration && declaration.name !== declaration.normalizedName) {
        const key = `${declaration.sourceFile}:${declaration.name}`;
        this.nameMap.set(key, declaration.normalizedName);
      }
    }
  }

  private generateExternalImports(): string[] {
    const lines: string[] = [];
    const sortedModules = Array.from(this.usedExternals.keys()).sort();

    for (const moduleName of sortedModules) {
      const imports = Array.from(this.usedExternals.get(moduleName) ?? []);
      if (imports.length === 0) continue;

      // Separate CommonJS import = require() from ES6 imports
      const cjsImports = imports.filter((imp) => imp.normalizedName.startsWith("= "));
      const esImports = imports.filter((imp) => !imp.normalizedName.startsWith("= "));

      // Emit CommonJS import = require() statements
      for (const cjsImport of cjsImports) {
        const importName = cjsImport.normalizedName.substring(2); // Remove "= " prefix
        lines.push(`import ${importName} = require("${moduleName}");`);
      }

      // Emit ES6 imports if any
      if (esImports.length === 0) continue;

      const isTypeOnly = esImports.every((imp) => imp.isTypeOnly);
      const typePrefix = isTypeOnly ? "type " : "";

      const hasNamespace = esImports.some((imp) => imp.normalizedName.startsWith("* as "));

      if (hasNamespace) {
        const importList = esImports.map((imp) => imp.normalizedName).sort();
        lines.push(`import ${typePrefix}${importList.join(", ")} from "${moduleName}";`);
      } else {
        const importList = esImports
          .map((imp) => imp.normalizedName)
          .filter((name) => !name.startsWith("default as "))
          .sort();

        if (importList.length > 0) {
          lines.push(`import ${typePrefix}{ ${importList.join(", ")} } from "${moduleName}";`);
        }
      }
    }

    return lines;
  }

  private generateDeclarations(): string[] {
    const lines: string[] = [];

    const sorted = this.topologicalSort();
    const ordered = this.options.sortNodes
      ? [...sorted].sort((a, b) => {
          const rank = OutputGenerator.getSortRank(a) - OutputGenerator.getSortRank(b);
          if (rank !== 0) return rank;
          return a.normalizedName.localeCompare(b.normalizedName);
        })
      : sorted;

    for (const declaration of ordered) {
      let text = declaration.getText();

      if (!declaration.isExported && text.includes("export ")) {
        text = OutputGenerator.stripExportModifier(text);
      }

      // Add declare keyword only to non-exported class/enum declarations
      // Interfaces and types don't need declare keyword in .d.ts files
      if (!declaration.isExported && !text.trim().startsWith("declare ")) {
        text = OutputGenerator.addDeclareKeyword(text);
      }

      // Strip implementation details for declaration files
      text = OutputGenerator.stripImplementationDetails(text);

      text = this.replaceRenamedReferences(text, declaration);

      lines.push(text);
    }

    return lines;
  }

  private static stripExportModifier(text: string): string {
    return text.replace(/^((?:\s*(?:\/\*[\s\S]*?\*\/\s*|\/\/[^\n]*\n\s*)*))export\s+/, "$1");
  }

  private static addDeclareKeyword(text: string): string {
    // Only add declare to class and enum (not interface, type, namespace, module)
    const match = text.match(/^((?:\s*(?:\/\*[\s\S]*?\*\/\s*|\/\/[^\n]*\n\s*)*))(class|enum)(?:\s|$)/);
    if (match) {
      const prefix = match[1]; // comments
      const declarationKeyword = match[2]; // class or enum
      const rest = text.substring(match[0].length - 1); // everything after the keyword
      return `${prefix}declare ${declarationKeyword}${rest}`;
    }
    return text;
  }

  /* eslint-disable no-param-reassign */
  private static stripImplementationDetails(text: string): string {
    // Strip public/private/protected modifiers from class members
    text = text.replace(/^(\s*)(public|private|protected)\s+/gm, "$1");

    // Strip property initializers (e.g., field: string = ""; becomes field: string;)
    // This should match property declarations (not methods) with initializers
    // Property pattern: identifier : type = value;
    // Avoid matching methods which have () in their signature
    text = text.replace(/^(\s*)([a-zA-Z_$][\w$]*)\s*:\s*([^;=()]+?)\s*=\s*[^;]+;/gm, "$1$2: $3;");

    return text;
  }
  /* eslint-enable no-param-reassign */

  private topologicalSort(): TypeDeclaration[] {
    const sorted: TypeDeclaration[] = [];
    const visited = new Set<symbol>();
    const visiting = new Set<symbol>();

    const visit = (id: symbol): void => {
      if (visited.has(id)) return;
      if (visiting.has(id)) {
        return;
      }

      visiting.add(id);
      const declaration = this.registry.getDeclaration(id);

      if (declaration) {
        for (const depId of declaration.dependencies) {
          if (this.usedDeclarations.has(depId)) {
            visit(depId);
          }
        }

        visiting.delete(id);
        visited.add(id);
        sorted.push(declaration);
      }
    };

    const used = Array.from(this.usedDeclarations);
    const exported = used.filter((id) => {
      const decl = this.registry.getDeclaration(id);
      return decl && decl.isExported;
    });
    const nonExported = used.filter((id) => {
      const decl = this.registry.getDeclaration(id);
      return decl && !decl.isExported;
    });

    for (const id of nonExported) {
      visit(id);
    }
    for (const id of exported) {
      visit(id);
    }

    return sorted;
  }

  private replaceRenamedReferences(text: string, declaration: TypeDeclaration): string {
    let result = text;

    if (declaration.name !== declaration.normalizedName) {
      const regex = new RegExp(`\\b(type|interface|class|enum)\\s+${declaration.name}\\b`, "g");
      result = result.replace(regex, `$1 ${declaration.normalizedName}`);
    }

    for (const depId of declaration.dependencies) {
      const depDecl = this.registry.getDeclaration(depId);
      if (depDecl && depDecl.name !== depDecl.normalizedName) {
        const regex = new RegExp(`\\b${depDecl.name}\\b(?![_])`, "g");
        result = result.replace(regex, depDecl.normalizedName);
      }
    }

    for (const [moduleName, importNames] of declaration.externalDependencies.entries()) {
      const moduleImports = this.registry.externalImports.get(moduleName);
      if (!moduleImports) continue;

      for (const importName of importNames) {
        const externalImport = moduleImports.get(importName);
        if (!externalImport) continue;

        const originalName = OutputGenerator.extractImportName(externalImport.originalName);
        const normalizedName = OutputGenerator.extractImportName(externalImport.normalizedName);

        if (originalName !== normalizedName) {
          const regex = new RegExp(`\\b${originalName}\\b(?![_])`, "g");
          result = result.replace(regex, normalizedName);
        }
      }
    }

    return result;
  }

  private static extractImportName(importStr: string): string {
    if (importStr.startsWith("default as ")) {
      return importStr.replace("default as ", "");
    }
    if (importStr.startsWith("* as ")) {
      return importStr.replace("* as ", "");
    }
    if (importStr.includes(" as ")) {
      const parts = importStr.split(" as ");
      return parts[1].trim();
    }
    return importStr;
  }

  private static getSortRank(declaration: TypeDeclaration): number {
    const node = declaration.node;
    if (ts.isInterfaceDeclaration(node)) return 1;
    if (ts.isTypeAliasDeclaration(node)) return 2;
    if (ts.isClassDeclaration(node)) return 3;
    if (ts.isEnumDeclaration(node)) return 4;
    if (ts.isModuleDeclaration(node)) return 5;
    return 10;
  }

  private generateReferenceDirectives(): string[] {
    const directives: string[] = [];
    const { referencedTypes, allowedTypesLibraries } = this.options;

    if (!referencedTypes || referencedTypes.size === 0 || !allowedTypesLibraries) {
      return directives;
    }

    // Generate triple-slash directives for types that are both:
    // 1. Referenced with preserve="true" in source files
    // 2. Listed in allowedTypesLibraries
    const sortedTypes = Array.from(referencedTypes).sort();
    for (const typeName of sortedTypes) {
      if (allowedTypesLibraries.includes(typeName)) {
        directives.push(`/// <reference types="${typeName}" />`);
      }
    }

    return directives;
  }
}
