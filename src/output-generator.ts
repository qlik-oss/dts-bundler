import ts from "typescript";
import pkg from "../package.json" assert { type: "json" };
import { AstPrinter } from "./ast-printer.js";
import { getModifiers, modifiersToMap, recreateRootLevelNodeWithModifiers } from "./helpers/ast-transformer.js";
import { normalizePrintedStatement } from "./helpers/print-normalizer.js";
import type { TypeRegistry } from "./registry.js";
import { ExportKind, type ExternalImport, type TypeDeclaration } from "./types.js";
import { VariableDeclarationEmitter } from "./variable-declaration-emitter.js";

const version = (pkg as { version?: string }).version ?? "development";

export class OutputGenerator {
  private registry: TypeRegistry;
  private usedDeclarations: Set<symbol>;
  private usedExternals: Map<string, Set<ExternalImport>>;
  private nameMap: Map<string, string>;
  private extraDefaultExports: Set<string>;
  private variableDeclarationEmitter: VariableDeclarationEmitter | null;
  private astPrinter: AstPrinter;
  private options: {
    noBanner?: boolean;
    sortNodes?: boolean;
    umdModuleName?: string;
    includeEmptyExport?: boolean;
    allowedTypesLibraries?: string[];
    importedLibraries?: string[];
    referencedTypes?: Set<string>;
    entryExportEquals?: ts.ExportAssignment | null;
    entryExportDefault?: ts.ExportAssignment | null;
    entryExportDefaultName?: string | null;
    typeChecker?: ts.TypeChecker;
  };

  constructor(
    registry: TypeRegistry,
    usedDeclarations: Set<symbol>,
    usedExternals: Map<string, Set<ExternalImport>>,
    options: {
      noBanner?: boolean;
      sortNodes?: boolean;
      umdModuleName?: string;
      includeEmptyExport?: boolean;
      allowedTypesLibraries?: string[];
      importedLibraries?: string[];
      referencedTypes?: Set<string>;
      entryExportEquals?: ts.ExportAssignment | null;
      entryExportDefault?: ts.ExportAssignment | null;
      entryExportDefaultName?: string | null;
      typeChecker?: ts.TypeChecker;
    } = {},
  ) {
    this.registry = registry;
    this.usedDeclarations = usedDeclarations;
    this.usedExternals = usedExternals;
    this.nameMap = new Map();
    this.extraDefaultExports = new Set();
    this.astPrinter = new AstPrinter();
    this.variableDeclarationEmitter = options.typeChecker
      ? new VariableDeclarationEmitter(
          options.typeChecker,
          (name) => this.extraDefaultExports.add(name),
          this.astPrinter,
          (declarations) => this.buildRenameMapForDeclarations(declarations),
        )
      : null;
    this.options = options;
  }

  generate(): string {
    const lines: string[] = [];

    const banner = !this.options.noBanner ? `// Generated by @qlik/dts-bundler@${version}` : null;
    const referenceDirectives = this.generateReferenceDirectives();
    const externalImports = this.usedExternals.size > 0 ? this.generateExternalImports() : [];

    this.buildNameMap();
    const declarations = this.generateDeclarations();
    const namespaces = this.generateNamespaces();
    const exportEquals = this.generateExportEquals();
    const starExports = this.generateStarExports();
    const namespaceExports = this.generateNamespaceExports();
    const exportDefault = this.generateExportDefault();

    const umdDeclaration = this.options.umdModuleName ? [`export as namespace ${this.options.umdModuleName};`] : [];
    const emptyExport = this.options.includeEmptyExport ? ["export {};"] : [];

    const appendSection = (section: string[]): void => {
      if (section.length === 0) return;
      if (lines.length > 0) lines.push("");
      lines.push(...section);
    };

    if (banner) {
      lines.push(banner);
    }

    appendSection(referenceDirectives);
    appendSection(externalImports);
    appendSection(namespaces);
    appendSection(declarations);

    // export = should appear immediately after declarations without blank line
    if (exportEquals.length > 0) {
      lines.push(...exportEquals);
    }

    appendSection(starExports);

    appendSection(namespaceExports.blocks);
    if (namespaceExports.exportList.length > 0) {
      if (lines.length > 0) lines.push("");
      lines.push(...namespaceExports.exportList);
    }

    // export default should appear after declarations
    if (exportDefault.length > 0) {
      if (lines.length > 0) lines.push("");
      lines.push(...exportDefault);
    }

    appendSection(umdDeclaration);
    appendSection(emptyExport);

    return `${lines.join("\n")}\n`;
  }

  private buildNameMap(): void {
    for (const id of this.usedDeclarations) {
      const declaration = this.registry.getDeclaration(id);
      if (declaration && declaration.name !== declaration.normalizedName) {
        const key = `${declaration.sourceFile}:${declaration.name}`;
        this.nameMap.set(key, declaration.normalizedName);
      }
    }
  }

  private generateExternalImports(): string[] {
    const lines: string[] = [];
    const sortedModules = Array.from(this.usedExternals.keys()).sort();

    for (const moduleName of sortedModules) {
      const imports = Array.from(this.usedExternals.get(moduleName) ?? []);
      if (imports.length === 0) continue;

      // Separate CommonJS import = require() from ES6 imports
      const cjsImports = imports.filter((imp) => imp.normalizedName.startsWith("= "));
      const esImports = imports.filter((imp) => !imp.normalizedName.startsWith("= "));

      // Emit CommonJS import = require() statements
      for (const cjsImport of cjsImports) {
        const importName = cjsImport.normalizedName.substring(2); // Remove "= " prefix
        lines.push(`import ${importName} = require("${moduleName}");`);
      }

      // Emit ES6 imports if any
      if (esImports.length === 0) continue;

      const isTypeOnly = esImports.every((imp) => imp.isTypeOnly);
      const typePrefix = isTypeOnly ? "type " : "";

      const hasNamespace = esImports.some((imp) => imp.normalizedName.startsWith("* as "));
      const defaultImports = esImports.filter((imp) => imp.normalizedName.startsWith("default as "));
      const namedImports = esImports.filter(
        (imp) => !imp.normalizedName.startsWith("* as ") && !imp.normalizedName.startsWith("default as "),
      );

      if (hasNamespace) {
        const importList = esImports.map((imp) => imp.normalizedName).sort();
        lines.push(`import ${typePrefix}${importList.join(", ")} from "${moduleName}";`);
      } else if (defaultImports.length > 0 && namedImports.length > 0) {
        // Both default and named imports
        const defaultName = defaultImports[0].normalizedName.substring("default as ".length);
        const namedList = namedImports.map((imp) => imp.normalizedName).sort();
        lines.push(`import ${typePrefix}${defaultName}, { ${namedList.join(", ")} } from "${moduleName}";`);
      } else if (defaultImports.length > 0) {
        // Only default imports
        for (const defaultImport of defaultImports) {
          const defaultName = defaultImport.normalizedName.substring("default as ".length);
          lines.push(`import ${typePrefix}${defaultName} from "${moduleName}";`);
        }
      } else if (namedImports.length > 0) {
        // Only named imports
        const importList = namedImports.map((imp) => imp.normalizedName).sort();
        lines.push(`import ${typePrefix}{ ${importList.join(", ")} } from "${moduleName}";`);
      }
    }

    return lines;
  }

  private generateDeclarations(): string[] {
    const lines: string[] = [];

    const sorted = this.topologicalSort();
    const ordered = this.options.sortNodes
      ? [...sorted].sort((a, b) => {
          const rank = OutputGenerator.getSortRank(a) - OutputGenerator.getSortRank(b);
          if (rank !== 0) return rank;
          return a.normalizedName.localeCompare(b.normalizedName);
        })
      : sorted;

    const variableStatementGroups = new Map<
      string,
      { statement: ts.VariableStatement; declarations: TypeDeclaration[] }
    >();
    for (const declaration of ordered) {
      if (ts.isVariableStatement(declaration.node)) {
        const statement = declaration.node;
        const key = OutputGenerator.getVariableStatementKey(declaration.sourceFile, statement);
        const group = variableStatementGroups.get(key);
        if (group) {
          group.declarations.push(declaration);
        } else {
          variableStatementGroups.set(key, { statement, declarations: [declaration] });
        }
      }
    }

    const processedVariableStatements = new Set<string>();
    const exportedModuleAugmentations = new Set<string>();
    for (const declId of this.usedDeclarations) {
      const decl = this.registry.getDeclaration(declId);
      if (!decl) continue;
      if (!ts.isModuleDeclaration(decl.node)) continue;
      if (!ts.isIdentifier(decl.node.name)) continue;
      if (decl.exportInfo.kind === ExportKind.NotExported && !decl.exportInfo.wasOriginallyExported) continue;
      exportedModuleAugmentations.add(decl.node.name.text);
    }

    for (const declaration of ordered) {
      if (ts.isVariableStatement(declaration.node)) {
        const statement = declaration.node;
        const key = OutputGenerator.getVariableStatementKey(declaration.sourceFile, statement);
        if (processedVariableStatements.has(key)) {
          continue;
        }
        processedVariableStatements.add(key);
        const group = variableStatementGroups.get(key);
        if (group && this.variableDeclarationEmitter) {
          const groupLines = this.variableDeclarationEmitter.generateVariableStatementLines(
            group.statement,
            group.declarations,
          );
          if (groupLines.length > 0) {
            lines.push(...groupLines);
            continue;
          }
        }
      }

      // Keep export keyword if the declaration was originally exported or is marked as exported
      // But suppress export if this declaration is exported via export = or export default statement
      const hasDefaultModifier =
        ts.canHaveModifiers(declaration.node) &&
        (ts.getModifiers(declaration.node)?.some((mod) => mod.kind === ts.SyntaxKind.DefaultKeyword) ?? false);
      const suppressExportForDefault = declaration.exportInfo.kind === ExportKind.Default && hasDefaultModifier;
      const suppressExportForModuleAugmentation =
        ts.isInterfaceDeclaration(declaration.node) && exportedModuleAugmentations.has(declaration.name);

      const shouldHaveExport =
        declaration.exportInfo.kind !== ExportKind.Equals &&
        !suppressExportForDefault &&
        !suppressExportForModuleAugmentation &&
        declaration.exportInfo.kind !== ExportKind.DefaultOnly &&
        (declaration.exportInfo.kind === ExportKind.Named || declaration.exportInfo.wasOriginallyExported);

      const transformedStatement = OutputGenerator.transformStatementForOutput(
        declaration,
        shouldHaveExport,
        suppressExportForDefault,
      );
      const renameMap = this.buildRenameMap(declaration);
      const printed = this.astPrinter.printStatement(transformedStatement, declaration.sourceFileNode, { renameMap });
      lines.push(normalizePrintedStatement(printed, declaration.node, declaration.getText()));
    }

    return lines;
  }

  private generateNamespaces(): string[] {
    const lines: string[] = [];
    const usedNamespaces = new Map<string, { sourceFile: string; declarations: symbol[] }>();

    // Find all namespace imports that are referenced in used declarations
    for (const declId of this.usedDeclarations) {
      const decl = this.registry.getDeclaration(declId);
      if (!decl) continue;

      // Check if this declaration has namespace dependencies
      for (const namespaceName of decl.namespaceDependencies) {
        // Find the namespace info from the registry
        const key = `${decl.sourceFile}:${namespaceName}`;
        const nsInfo = this.registry.namespaceImports.get(key);

        if (nsInfo && !usedNamespaces.has(namespaceName)) {
          // Collect all declarations from the source file
          const fileDeclarations = this.registry.declarationsByFile.get(nsInfo.sourceFile);
          if (fileDeclarations) {
            const usedFromFile = Array.from(fileDeclarations).filter((id) => this.usedDeclarations.has(id));
            if (usedFromFile.length > 0) {
              usedNamespaces.set(namespaceName, {
                sourceFile: nsInfo.sourceFile,
                declarations: usedFromFile,
              });
            }
          }
        }
      }
    }

    // Generate namespace blocks
    for (const [namespaceName, info] of usedNamespaces.entries()) {
      lines.push(`declare namespace ${namespaceName} {`);

      for (const declId of info.declarations) {
        const declaration = this.registry.getDeclaration(declId);
        if (!declaration) continue;

        // Export the declaration within the namespace using its original name
        lines.push(`  export { ${declaration.name} };`);
      }

      lines.push(`}`);
    }

    return lines;
  }

  private generateExportEquals(): string[] {
    if (!this.options.entryExportEquals) {
      return [];
    }

    const statement = this.options.entryExportEquals;
    if (!ts.isIdentifier(statement.expression)) {
      return [];
    }

    const exportedName = statement.expression.text;
    const normalizedName = this.nameMap.get(exportedName) || exportedName;

    return [`export = ${normalizedName};`];
  }

  private generateExportDefault(): string[] {
    if (this.options.entryExportDefaultName) {
      return [this.buildDefaultExportLine(this.options.entryExportDefaultName)];
    }

    if (!this.options.entryExportDefault) {
      return [];
    }

    const statement = this.options.entryExportDefault;
    const expression = statement.expression;

    let exportedName: string;

    if (ts.isIdentifier(expression)) {
      // export default SomeIdentifier
      exportedName = expression.text;
      return [this.buildDefaultExportLine(exportedName)];
    }

    if (
      (ts.isClassDeclaration(expression) ||
        ts.isFunctionDeclaration(expression) ||
        ts.isInterfaceDeclaration(expression) ||
        ts.isEnumDeclaration(expression)) &&
      expression.name
    ) {
      // export default class/function/etc with a name
      exportedName = expression.name.text;
    } else {
      // export default <expression without name>
      return [];
    }

    const normalizedName = this.nameMap.get(exportedName) || exportedName;

    return [`export { ${normalizedName} as default };`];
  }

  private buildDefaultExportLine(exportedName: string): string {
    const normalizedName = this.nameMap.get(exportedName) || exportedName;
    const extraExports = Array.from(this.extraDefaultExports).filter((name) => name !== normalizedName);
    const exportItems = [`${normalizedName} as default`, ...extraExports];
    return `export { ${exportItems.join(", ")} };`;
  }

  private generateStarExports(): string[] {
    const lines: string[] = [];
    if (this.registry.entryStarExports.length === 0) return lines;

    const seen = new Set<string>();
    const visitedFiles = new Set<string>();

    const pushExternal = (moduleName: string, isTypeOnly = false): void => {
      const key = `${moduleName}:${isTypeOnly ? "type" : "value"}`;
      if (seen.has(key)) return;
      seen.add(key);
      const typePrefix = isTypeOnly ? "type " : "";
      lines.push(`export ${typePrefix}* from "${moduleName}";`);
    };

    const collectFromFile = (filePath: string): void => {
      if (visitedFiles.has(filePath)) return;
      visitedFiles.add(filePath);

      for (const starExport of this.registry.getStarExports(filePath)) {
        if (starExport.externalModule) {
          pushExternal(starExport.externalModule, starExport.isTypeOnly ?? false);
        } else if (starExport.targetFile) {
          collectFromFile(starExport.targetFile);
        }
      }
    };

    for (const entry of this.registry.entryStarExports) {
      if (entry.info.externalModule) {
        pushExternal(entry.info.externalModule, entry.info.isTypeOnly ?? false);
      } else if (entry.info.targetFile) {
        collectFromFile(entry.info.targetFile);
      }
    }

    return lines;
  }

  private generateNamespaceExports(): { blocks: string[]; exportList: string[] } {
    const blocks: string[] = [];
    const exportNames: string[] = [];

    if (this.registry.entryNamespaceExports.length === 0) {
      return { blocks, exportList: [] };
    }

    const depthCache = new Map<string, number>();
    const entryExports = this.registry.entryNamespaceExports.map((entry) => ({
      entry,
      depth: this.getNamespaceExportDepth(entry, depthCache),
    }));

    entryExports.sort((a, b) => b.depth - a.depth);

    const visited = new Set<string>();
    for (const { entry } of entryExports) {
      const info = this.registry.getNamespaceExportInfo(entry.sourceFile, entry.name);
      if (!info) continue;
      this.buildNamespaceBlocks(entry.sourceFile, entry.name, info, visited, blocks);
    }

    for (const entry of this.registry.entryNamespaceExports) {
      exportNames.push(entry.name);
    }

    const exportList = exportNames.length > 0 ? [`export { ${exportNames.join(", ")} };`] : [];
    return { blocks, exportList };
  }

  private buildNamespaceBlocks(
    sourceFile: string,
    namespaceName: string,
    info: { targetFile?: string; externalModule?: string; externalImportName?: string },
    visited: Set<string>,
    blocks: string[],
  ): void {
    const key = `${sourceFile}:${namespaceName}`;
    if (visited.has(key)) return;
    visited.add(key);

    if (!info.targetFile) {
      return;
    }

    const exportedNames = this.registry.exportedNamesByFile.get(info.targetFile) ?? [];

    for (const exported of exportedNames) {
      const childInfo = this.registry.getNamespaceExportInfo(info.targetFile, exported.name);
      if (childInfo && childInfo.targetFile) {
        this.buildNamespaceBlocks(info.targetFile, exported.name, childInfo, visited, blocks);
      }
    }

    const exportList = exportedNames.map((item) => item.name);
    blocks.push(`declare namespace ${namespaceName} {`);
    if (exportList.length > 0) {
      blocks.push(`  export { ${exportList.join(", ")} };`);
    }
    blocks.push(`}`);
  }

  private getNamespaceExportDepth(
    entry: { name: string; sourceFile: string },
    depthCache: Map<string, number>,
  ): number {
    const key = `${entry.sourceFile}:${entry.name}`;
    if (depthCache.has(key)) return depthCache.get(key) as number;

    const info = this.registry.getNamespaceExportInfo(entry.sourceFile, entry.name);
    if (!info || !info.targetFile) {
      depthCache.set(key, 1);
      return 1;
    }

    const exportedNames = this.registry.exportedNamesByFile.get(info.targetFile) ?? [];
    let maxChild = 0;
    for (const exported of exportedNames) {
      const childInfo = this.registry.getNamespaceExportInfo(info.targetFile, exported.name);
      if (childInfo && childInfo.targetFile) {
        const childDepth = this.getNamespaceExportDepth(
          { name: exported.name, sourceFile: info.targetFile },
          depthCache,
        );
        if (childDepth > maxChild) {
          maxChild = childDepth;
        }
      }
    }

    const depth = 1 + maxChild;
    depthCache.set(key, depth);
    return depth;
  }

  /* eslint-disable no-param-reassign */
  private static stripExportModifier(text: string): string {
    // Strip both "export default" and "export", handling leading whitespace
    text = text.replace(/export\s+default\s+/, "");
    text = text.replace(/export\s+/, "");
    return text;
  }
  /* eslint-enable no-param-reassign */

  private static addDeclareKeyword(text: string): string {
    // Only add declare to class, enum, function, namespace, and module (not interface or type)
    // Handle both "export class" and "class" patterns
    const match = text.match(
      /^((?:\s*(?:\/\*[\s\S]*?\*\/\s*|\/\/[^\n]*\n\s*)*)(?:export\s+)?)(class|enum|function|namespace|module)(?:\s|$)/,
    );
    if (match) {
      const prefix = match[1]; // comments and export keyword
      const declarationKeyword = match[2]; // class, enum, or function
      const rest = text.substring(match[0].length - 1); // everything after the keyword
      return `${prefix}declare ${declarationKeyword}${rest}`;
    }
    return text;
  }

  private static stripNamespaceMemberExports(text: string): string {
    const openBraceIndex = text.indexOf("{");
    const closeBraceIndex = text.lastIndexOf("}");
    if (openBraceIndex === -1 || closeBraceIndex === -1 || closeBraceIndex <= openBraceIndex) {
      return text;
    }

    const prefix = text.slice(0, openBraceIndex + 1);
    const body = text.slice(openBraceIndex + 1, closeBraceIndex);
    const suffix = text.slice(closeBraceIndex);

    const cleanedBody = body.replace(
      /(^|\n)(\s*)export\s+(?=(?:declare\s+)?(?:namespace|module|interface|type|class|enum|const|let|var|function)\b)/g,
      "$1$2",
    );

    return `${prefix}${cleanedBody}${suffix}`;
  }

  private static stripDeclareGlobalMemberExports(text: string): string {
    const openBraceIndex = text.indexOf("{");
    const closeBraceIndex = text.lastIndexOf("}");
    if (openBraceIndex === -1 || closeBraceIndex === -1 || closeBraceIndex <= openBraceIndex) {
      return text;
    }

    const prefix = text.slice(0, openBraceIndex + 1);
    const body = text.slice(openBraceIndex + 1, closeBraceIndex);
    const suffix = text.slice(closeBraceIndex);

    const cleanedBody = body.replace(
      /(^|\n)(\s*)export\s+(?=(?:declare\s+)?(?:interface|type|class|enum|const|let|var|function)\b)/g,
      "$1$2",
    );

    return `${prefix}${cleanedBody}${suffix}`;
  }

  /* eslint-disable no-param-reassign */
  private static stripImplementationDetails(text: string): string {
    // Strip public/private/protected modifiers from class members
    text = text.replace(/^(\s*)(public|private|protected)\s+/gm, "$1");

    // Strip property initializers (e.g., field: string = ""; becomes field: string;)
    // This should match property declarations (not methods) with initializers
    // Property pattern: identifier : type = value;
    // Avoid matching methods which have () in their signature
    text = text.replace(/^(\s*)([a-zA-Z_$][\w$]*)\s*:\s*([^;=()]+?)\s*=\s*[^;]+;/gm, "$1$2: $3;");

    // Strip function bodies - replace { ... } with just semicolon
    text = text.replace(/^((?:export\s+)?(?:declare\s+)?function\s+[^{]+?)\s*\{[^}]*\}/gm, "$1;");

    return text;
  }
  /* eslint-enable no-param-reassign */

  private static getVariableStatementKey(sourceFile: string, statement: ts.VariableStatement): string {
    return `${sourceFile}:${statement.pos}:${statement.end}`;
  }

  private topologicalSort(): TypeDeclaration[] {
    const sorted: TypeDeclaration[] = [];
    const visited = new Set<symbol>();
    const visiting = new Set<symbol>();

    const visit = (id: symbol): void => {
      if (visited.has(id)) return;
      if (visiting.has(id)) {
        return;
      }

      visiting.add(id);
      const declaration = this.registry.getDeclaration(id);

      if (declaration) {
        for (const depId of declaration.dependencies) {
          if (this.usedDeclarations.has(depId)) {
            visit(depId);
          }
        }

        visiting.delete(id);
        visited.add(id);
        sorted.push(declaration);
      }
    };

    const used = Array.from(this.usedDeclarations);
    const exported = used.filter((id) => {
      const decl = this.registry.getDeclaration(id);
      return decl && decl.exportInfo.kind !== ExportKind.NotExported;
    });
    const nonExported = used.filter((id) => {
      const decl = this.registry.getDeclaration(id);
      return decl && decl.exportInfo.kind === ExportKind.NotExported;
    });

    for (const id of nonExported) {
      visit(id);
    }
    for (const id of exported) {
      visit(id);
    }

    return sorted;
  }

  private buildRenameMap(declaration: TypeDeclaration): Map<string, string> {
    const renameMap = new Map<string, string>();

    if (declaration.name !== declaration.normalizedName) {
      renameMap.set(declaration.name, declaration.normalizedName);
    }

    for (const depId of declaration.dependencies) {
      const depDecl = this.registry.getDeclaration(depId);
      if (depDecl && depDecl.name !== depDecl.normalizedName) {
        renameMap.set(depDecl.name, depDecl.normalizedName);
      }
    }

    for (const [moduleName, importNames] of declaration.externalDependencies.entries()) {
      const moduleImports = this.registry.externalImports.get(moduleName);
      if (!moduleImports) continue;

      for (const importName of importNames) {
        const externalImport = moduleImports.get(importName);
        if (!externalImport) continue;

        const originalName = OutputGenerator.extractImportName(externalImport.originalName);
        const normalizedName = OutputGenerator.extractImportName(externalImport.normalizedName);

        if (originalName !== normalizedName) {
          renameMap.set(originalName, normalizedName);
        }
      }
    }

    return renameMap;
  }

  private buildRenameMapForDeclarations(declarations: TypeDeclaration[]): Map<string, string> {
    const merged = new Map<string, string>();
    for (const declaration of declarations) {
      for (const [name, normalized] of this.buildRenameMap(declaration)) {
        merged.set(name, normalized);
      }
    }

    return merged;
  }

  private static extractImportName(importStr: string): string {
    if (importStr.startsWith("default as ")) {
      return importStr.replace("default as ", "");
    }
    if (importStr.startsWith("* as ")) {
      return importStr.replace("* as ", "");
    }
    if (importStr.includes(" as ")) {
      const parts = importStr.split(" as ");
      return parts[1].trim();
    }
    return importStr;
  }

  private static getSortRank(declaration: TypeDeclaration): number {
    const node = declaration.node;
    if (ts.isInterfaceDeclaration(node)) return 1;
    if (ts.isTypeAliasDeclaration(node)) return 2;
    if (ts.isClassDeclaration(node)) return 3;
    if (ts.isEnumDeclaration(node)) return 4;
    if (ts.isModuleDeclaration(node)) return 5;
    return 10;
  }

  private generateReferenceDirectives(): string[] {
    const directives: string[] = [];
    const { referencedTypes, allowedTypesLibraries } = this.options;

    if (!referencedTypes || referencedTypes.size === 0 || !allowedTypesLibraries) {
      return directives;
    }

    // Generate triple-slash directives for types that are both:
    // 1. Referenced with preserve="true" in source files
    // 2. Listed in allowedTypesLibraries
    const sortedTypes = Array.from(referencedTypes).sort();
    for (const typeName of sortedTypes) {
      if (allowedTypesLibraries.includes(typeName)) {
        directives.push(`/// <reference types="${typeName}" />`);
      }
    }

    return directives;
  }

  private static transformStatementForOutput(
    declaration: TypeDeclaration,
    shouldHaveExport: boolean,
    suppressExportForDefault: boolean,
  ): ts.Statement {
    let statement = declaration.node as ts.Statement;
    const modifiersMap = modifiersToMap(getModifiers(statement));

    const hadExport = Boolean(modifiersMap[ts.SyntaxKind.ExportKeyword]);
    const shouldForceExport = shouldHaveExport && OutputGenerator.shouldForceExport(statement);
    modifiersMap[ts.SyntaxKind.ExportKeyword] = (hadExport || shouldForceExport) && shouldHaveExport;
    if (suppressExportForDefault) {
      modifiersMap[ts.SyntaxKind.DefaultKeyword] = false;
    }

    if (OutputGenerator.shouldAddDeclareKeyword(statement)) {
      modifiersMap[ts.SyntaxKind.DeclareKeyword] = true;
    }

    statement = recreateRootLevelNodeWithModifiers(statement, modifiersMap) as ts.Statement;

    const result = ts.transform(statement, [OutputGenerator.createOutputTransformer()]);
    const transformed = result.transformed[0] as ts.Statement;
    result.dispose();
    return transformed;
  }

  private static createOutputTransformer(): ts.TransformerFactory<ts.Statement> {
    return (context) => {
      const visit: ts.Visitor = (node) => {
        if (OutputGenerator.shouldStripNamespaceMemberExport(node)) {
          return OutputGenerator.stripExportFromStatement(node as ts.Statement, false);
        }

        if (ts.isFunctionDeclaration(node) && node.body) {
          const updated = ts.factory.updateFunctionDeclaration(
            node,
            node.modifiers,
            node.asteriskToken,
            node.name,
            node.typeParameters,
            node.parameters,
            node.type,
            undefined,
          );
          ts.setTextRange(updated, node);
          return updated;
        }

        if (ts.isClassDeclaration(node)) {
          const members = node.members.map((member) => OutputGenerator.stripClassMemberImplementation(member));
          const updated = ts.factory.updateClassDeclaration(
            node,
            node.modifiers,
            node.name,
            node.typeParameters,
            node.heritageClauses,
            members,
          );
          ts.setTextRange(updated, node);
          return updated;
        }

        if (ts.isModuleDeclaration(node)) {
          // eslint-disable-next-line no-bitwise
          const isDeclareGlobal = (node.flags & ts.NodeFlags.GlobalAugmentation) !== 0;
          const isExternalModule = ts.isStringLiteral(node.name) || ts.isNoSubstitutionTemplateLiteral(node.name);
          let body = node.body;
          if (body && ts.isModuleBlock(body)) {
            const statements = isExternalModule
              ? body.statements
              : body.statements.map((statement) =>
                  OutputGenerator.stripExportFromStatement(statement, isDeclareGlobal),
                );
            body = ts.factory.updateModuleBlock(body, statements);
          }

          let flags = node.flags;
          if (!isDeclareGlobal && ts.isIdentifier(node.name) && OutputGenerator.isNamespaceDeclaration(node)) {
            // eslint-disable-next-line no-bitwise
            flags |= ts.NodeFlags.Namespace;
          }

          const updated = ts.factory.createModuleDeclaration(node.modifiers, node.name, body, flags);
          ts.setTextRange(updated, node);
          return ts.visitEachChild(updated, visit, context);
        }

        return ts.visitEachChild(node, visit, context);
      };

      return (rootNode) => ts.visitNode(rootNode, visit) as ts.Statement;
    };
  }

  private static stripClassMemberImplementation(member: ts.ClassElement): ts.ClassElement {
    const modifiers = getModifiers(member);
    if (ts.isPropertyDeclaration(member)) {
      const filteredModifiers = OutputGenerator.stripAccessModifiers(modifiers);
      const updated = ts.factory.updatePropertyDeclaration(
        member,
        filteredModifiers,
        member.name,
        member.questionToken ?? member.exclamationToken,
        member.type,
        undefined,
      );
      ts.setTextRange(updated, member);
      return updated;
    }

    if (modifiers) {
      const filteredModifiers = OutputGenerator.stripAccessModifiers(modifiers);
      if (filteredModifiers !== modifiers) {
        if (ts.isMethodDeclaration(member)) {
          const updated = ts.factory.updateMethodDeclaration(
            member,
            filteredModifiers,
            member.asteriskToken,
            member.name,
            member.questionToken,
            member.typeParameters,
            member.parameters,
            member.type,
            member.body,
          );
          ts.setTextRange(updated, member);
          return updated;
        }
      }
    }

    return member;
  }

  private static stripExportFromStatement(statement: ts.Statement, preserveNamespaceExport: boolean): ts.Statement {
    if (preserveNamespaceExport && ts.isModuleDeclaration(statement)) {
      return statement;
    }

    const modifiers = getModifiers(statement);
    if (!modifiers) {
      return statement;
    }

    const modifiersMap = modifiersToMap(modifiers);
    if (!modifiersMap[ts.SyntaxKind.ExportKeyword]) {
      return statement;
    }

    modifiersMap[ts.SyntaxKind.ExportKeyword] = false;
    return recreateRootLevelNodeWithModifiers(statement, modifiersMap) as ts.Statement;
  }

  private static shouldStripNamespaceMemberExport(node: ts.Node): boolean {
    if (!ts.isStatement(node)) {
      return false;
    }

    const parentBlock = (node as Omit<ts.Node, "parent"> & { parent?: ts.Node }).parent;
    if (!parentBlock) {
      return false;
    }
    if (!ts.isModuleBlock(parentBlock)) {
      return false;
    }

    const moduleDecl = parentBlock.parent;
    if (!ts.isModuleDeclaration(moduleDecl)) {
      return false;
    }

    const isExternalModule = ts.isStringLiteral(moduleDecl.name) || ts.isNoSubstitutionTemplateLiteral(moduleDecl.name);
    if (isExternalModule) {
      return false;
    }

    return !ts.isModuleDeclaration(node);
  }

  private static shouldAddDeclareKeyword(statement: ts.Statement): boolean {
    if (statement.getSourceFile().isDeclarationFile) {
      return false;
    }

    if (
      ts.isClassDeclaration(statement) ||
      ts.isEnumDeclaration(statement) ||
      ts.isFunctionDeclaration(statement) ||
      ts.isModuleDeclaration(statement)
    ) {
      return true;
    }

    return false;
  }

  private static isNamespaceDeclaration(node: ts.ModuleDeclaration): boolean {
    const sourceFile = node.getSourceFile();
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (!sourceFile) {
      return false;
    }

    const text = sourceFile.text.slice(node.pos, node.end);
    const header = text.split("{")[0] ?? text;
    if (/\bdeclare\s+module\b/.test(header)) {
      return false;
    }

    return /\bnamespace\b/.test(header) || /\bmodule\b/.test(header);
  }

  private static shouldForceExport(statement: ts.Statement): boolean {
    if (!ts.isModuleDeclaration(statement)) {
      return false;
    }

    if (!ts.isIdentifier(statement.name)) {
      return false;
    }

    if (OutputGenerator.isNamespaceDeclaration(statement)) {
      return false;
    }

    // eslint-disable-next-line no-bitwise
    if ((statement.flags & ts.NodeFlags.GlobalAugmentation) !== 0) {
      return false;
    }

    return true;
  }

  private static stripAccessModifiers(
    modifiers: readonly ts.Modifier[] | undefined,
  ): readonly ts.Modifier[] | undefined {
    if (!modifiers || modifiers.length === 0) {
      return modifiers;
    }

    const filtered = modifiers.filter(
      (modifier) =>
        modifier.kind !== ts.SyntaxKind.PublicKeyword &&
        modifier.kind !== ts.SyntaxKind.PrivateKeyword &&
        modifier.kind !== ts.SyntaxKind.ProtectedKeyword,
    );

    return filtered.length === modifiers.length ? modifiers : filtered;
  }
}
